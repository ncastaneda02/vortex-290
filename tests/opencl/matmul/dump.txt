g++ -std=c++11 -Wall -Wextra -Wfatal-errors -Wno-deprecated-declarations -Wno-unused-parameter -Wno-narrowing -pthread -I/scratch/nicolas.a.castaneda/build/pocl2/runtime/include -O2 -DNDEBUG -MM main.cc > .depend;
g++ -std=c++11 -Wall -Wextra -Wfatal-errors -Wno-deprecated-declarations -Wno-unused-parameter -Wno-narrowing -pthread -I/scratch/nicolas.a.castaneda/build/pocl2/runtime/include -O2 -DNDEBUG -c main.cc -o main.cc.o
In file included from /scratch/nicolas.a.castaneda/build/pocl2/runtime/include/CL/cl.h:20,
                 from /scratch/nicolas.a.castaneda/build/pocl2/runtime/include/CL/opencl.h:24,
                 from main.cc:4:
/scratch/nicolas.a.castaneda/build/pocl2/runtime/include/CL/cl_version.h:22:104: note: #pragma message: cl_version.h: CL_TARGET_OPENCL_VERSION is not defined. Defaulting to 300 (OpenCL 3.0)
   22 | #pragma message("cl_version.h: CL_TARGET_OPENCL_VERSION is not defined. Defaulting to 300 (OpenCL 3.0)")
      |                                                                                                        ^
g++ -std=c++11 -Wall -Wextra -Wfatal-errors -Wno-deprecated-declarations -Wno-unused-parameter -Wno-narrowing -pthread -I/scratch/nicolas.a.castaneda/build/pocl2/runtime/include -O2 -DNDEBUG main.cc.o -L/home/eecs/nicolas.a.castaneda/vortex2/runtime/stub -lvortex /scratch/nicolas.a.castaneda/build/pocl2/runtime/lib/libOpenCL.so -o matmul
LD_LIBRARY_PATH=/scratch/nicolas.a.castaneda/build/llvm-vortex/lib:/scratch/nicolas.a.castaneda/build/pocl2/compiler/lib:/scratch/nicolas.a.castaneda/build/llvm-vortex/lib:/usr/local/cuda-12.2/lib64:/usr/local/cuda-12.2/lib64:/usr/local/cuda-12.2/lib64: LLVM_PREFIX=/scratch/nicolas.a.castaneda/build/llvm-vortex POCL_DEBUG=all POCL_VORTEX_CFLAGS="-march=rv32imaf -mabi=ilp32f -v -O3 --sysroot=/home/eecs/nicolas.a.castaneda/vortex-toolchain-prebuilt/riscv-gnu-toolchain/riscv32-unknown-elf --gcc-toolchain=/home/eecs/nicolas.a.castaneda/vortex-toolchain-prebuilt/riscv-gnu-toolchain -Xclang -target-feature -Xclang +vortex -fno-rtti -fno-exceptions -nostartfiles -fdata-sections -ffunction-sections -I/home/eecs/nicolas.a.castaneda/vortex2/kernel/include -DNDEBUG -DLLVM_VOTEX" POCL_VORTEX_LDFLAGS="-Wl,-Bstatic,--gc-sections,-T/home/eecs/nicolas.a.castaneda/vortex2/kernel/linker/vx_link32.ld,--defsym=STARTUP_ADDR=0x80000000 /home/eecs/nicolas.a.castaneda/vortex2/kernel/libvortexrt.a -lm" /scratch/nicolas.a.castaneda/build/pocl2/compiler/bin/poclcc -o kernel.pocl kernel.cl
** Final POCL_DEBUG flags: FFFFFFFFFFFFFFFF 
[2024-05-06 22:53:27.198095484] POCL: in fn pocl_install_sigfpe_handler at line 265:
  *** INFO ***  |   GENERAL |  Installing SIGFPE handler...
[2024-05-06 22:53:27.198605433] POCL: in fn pocl_vortex_init at line 276:
  *** WARNING ***  |   WARNING |  INIT dlcache DOTO delete
[2024-05-06 22:53:27.198695584] POCL: in fn pocl_vortex_init at line 297:
  *** WARNING ***  |   WARNING |  GLOBAL_MEM_SIZE  : -1073741824
[2024-05-06 22:53:27.199903064] POCL: in fn POclCreateCommandQueue at line 103:
  *** INFO ***  |   GENERAL |  Created Command Queue 3 (0x564a19535470) on device 0
[2024-05-06 22:53:27.199977659] POCL: in fn void pocl_llvm_create_context(cl_context) at line 436:
  *** INFO ***  |      LLVM |  Created context 2 (0x564a19534830)
[2024-05-06 22:53:27.199981501] POCL: in fn POclCreateContext at line 232:
  *** INFO ***  |   GENERAL |  Created Context 2 (0x564a19534830)
[2024-05-06 22:53:27.199992965] POCL: in fn POclRetainContext at line 32:
  *** INFO ***  | REFCOUNTS |  Retain Context 2 (0x564a19534830), Refcount: 2
[2024-05-06 22:53:27.199997007] POCL: in fn compile_and_link_program at line 793:
  *** INFO ***  |      LLVM |  building program with options (null)
[2024-05-06 22:53:27.199999964] POCL: in fn compile_and_link_program at line 830:
  *** INFO ***  |      LLVM |  building program for 1 devs with options (null)
[2024-05-06 22:53:27.200002293] POCL: in fn compile_and_link_program at line 834:
  *** INFO ***  |      LLVM |     BUILDING for device: Vortex
[2024-05-06 22:53:27.200005297] POCL: in fn pocl_driver_build_source at line 712:
  *** INFO ***  |      LLVM |  building from sources for device 0
[2024-05-06 22:53:27.200219976] POCL: in fn int pocl_llvm_build_program(cl_program, unsigned int, cl_uint, _cl_program* const*, const char**, int) at line 425:
  *** INFO ***  |      LLVM |  all build options: -Dcl_khr_int64 -DPOCL_DEVICE_ADDRESS_BITS=32 -D__USE_CLANG_OPENCL_C_H -xcl -Dinline= -I. -cl-kernel-arg-info -opaque-pointers  -D__ENDIAN_LITTLE__=1 -D__IMAGE_SUPPORT__=1 -DCL_DEVICE_MAX_GLOBAL_VARIABLE_SIZE=0 -D__OPENCL_VERSION__=300 -cl-std=CL3.0 -D__OPENCL_C_VERSION__=300 -Dcl_khr_byte_addressable_store=1 -Dcl_khr_global_int32_base_atomics=1 -Dcl_khr_global_int32_extended_atomics=1 -Dcl_khr_local_int32_base_atomics=1 -Dcl_khr_local_int32_extended_atomics=1 -D__opencl_c_images=1 -cl-ext=-all,+cl_khr_byte_addressable_store,+cl_khr_global_int32_base_atomics,+cl_khr_global_int32_extended_atomics,+cl_khr_local_int32_base_atomics,+cl_khr_local_int32_extended_atomics,+__opencl_c_images -fno-builtin -triple=riscv32 -target-feature +m -target-feature +f -target-feature +vortex -target-abi ilp32f
Creating vortex barriers in: matmul
Vortex really on? 1
Searching for barriers in: matmul
Found a barrier in: pocl.barrier
Found a barrier in: pocl.barrier
Found a barrier in: pocl.barrier
Found a barrier in: pocl.barrier
Found a barrier in: pocl.barrier
Found a barrier in: pocl.barrier
Found a barrier in: pocl.barrier
Found a barrier in: pocl.barrier
Found a barrier in: pocl.barrier
Found a barrier in: pocl.barrier
Found a barrier in: pocl.barrier
[2024-05-06 22:53:28.064631627] POCL: in fn int pocl_llvm_generate_workgroup_function_nowrite(unsigned int, cl_device_id, cl_kernel, _cl_command_node*, void**, int) at line 757:
  *** INFO ***  |    TIMING |       >>>       577.757  ms    API: llvm_workgroup_ir_func_gen
[2024-05-06 22:53:28.068114636] POCL: in fn llvm_codegen at line 535:
  *** INFO ***  |      LLVM |  Writing parallel.bc to /home/eecs/nicolas.a.castaneda/.cache/pocl/kcache/PH/OJHLLAIOAHLNICJFIGMMKLAIJOPDBOGOODMAO/matmul/0-0-0/parallel.bc.
[2024-05-06 22:53:28.084679614] POCL: in fn int pocl_llvm_build_vortex_program(cl_kernel, unsigned int, cl_device_id, const char*, const char*, char*) at line 100:
  *** INFO ***  |   GENERAL |  using $LLVM_PREFIX=/scratch/nicolas.a.castaneda/build/llvm-vortex!
[2024-05-06 22:53:28.084699879] POCL: in fn int pocl_llvm_build_vortex_program(cl_kernel, unsigned int, cl_device_id, const char*, const char*, char*) at line 111:
  *** INFO ***  |      LLVM |  running "/scratch/nicolas.a.castaneda/build/llvm-vortex/bin/clang -march=rv32imaf -mabi=ilp32f -v -O3 --sysroot=/home/eecs/nicolas.a.castaneda/vortex-toolchain-prebuilt/riscv-gnu-toolchain/riscv32-unknown-elf --gcc-toolchain=/home/eecs/nicolas.a.castaneda/vortex-toolchain-prebuilt/riscv-gnu-toolchain -Xclang -target-feature -Xclang +vortex -fno-rtti -fno-exceptions -nostartfiles -fdata-sections -ffunction-sections -I/home/eecs/nicolas.a.castaneda/vortex2/kernel/include -DNDEBUG -DLLVM_VOTEX /home/eecs/nicolas.a.castaneda/.cache/pocl/kcache/PH/OJHLLAIOAHLNICJFIGMMKLAIJOPDBOGOODMAO/matmul/0-0-0/parallel.bc -c -o /home/eecs/nicolas.a.castaneda/.cache/pocl/kcache/tempfile_ySArAn.so.o"
clang version 16.0.6 (https://github.com/vortexgpgpu/llvm 58811bfa61a503fd4a5f0dc7b57802fae51c3f5d)
Target: riscv32-unknown-unknown-elf
Thread model: posix
InstalledDir: /scratch/nicolas.a.castaneda/build/llvm-vortex/bin
Found candidate GCC installation: /home/eecs/nicolas.a.castaneda/vortex-toolchain-prebuilt/riscv-gnu-toolchain/lib/gcc/riscv32-unknown-elf/12.2.0
Selected GCC installation: /home/eecs/nicolas.a.castaneda/vortex-toolchain-prebuilt/riscv-gnu-toolchain/lib/gcc/riscv32-unknown-elf/12.2.0
clang-16: warning: argument unused during compilation: '-nostartfiles' [-Wunused-command-line-argument]
clang-16: warning: argument unused during compilation: '-I /home/eecs/nicolas.a.castaneda/vortex2/kernel/include' [-Wunused-command-line-argument]
 (in-process)
 "/scratch/nicolas.a.castaneda/build/llvm-vortex/bin/clang-16" -cc1 -triple riscv32-unknown-unknown-elf -emit-obj -disable-free -clear-ast-before-backend -main-file-name parallel.bc -mrelocation-model static -mframe-pointer=none -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -nostdsysteminc -target-cpu generic-rv32 -target-feature +m -target-feature +a -target-feature +f -target-feature -e -target-feature -d -target-feature -c -target-feature -h -target-feature -zihintpause -target-feature -zfhmin -target-feature -zfh -target-feature -zfinx -target-feature -zdinx -target-feature -zhinxmin -target-feature -zhinx -target-feature -zba -target-feature -zbb -target-feature -zbc -target-feature -zbs -target-feature -zbkb -target-feature -zbkc -target-feature -zbkx -target-feature -zknd -target-feature -zkne -target-feature -zknh -target-feature -zksed -target-feature -zksh -target-feature -zkr -target-feature -zkn -target-feature -zks -target-feature -zkt -target-feature -zk -target-feature -zmmul -target-feature -v -target-feature -zvl32b -target-feature -zvl64b -target-feature -zvl128b -target-feature -zvl256b -target-feature -zvl512b -target-feature -zvl1024b -target-feature -zvl2048b -target-feature -zvl4096b -target-feature -zvl8192b -target-feature -zvl16384b -target-feature -zvl32768b -target-feature -zvl65536b -target-feature -zve32x -target-feature -zve32f -target-feature -zve64x -target-feature -zve64f -target-feature -zve64d -target-feature -zicbom -target-feature -zicboz -target-feature -zicbop -target-feature -svnapot -target-feature -svpbmt -target-feature -svinval -target-feature -xventanacondops -target-feature -xtheadvdot -target-feature -experimental-zihintntl -target-feature -experimental-zca -target-feature -experimental-zcd -target-feature -experimental-zcf -target-feature -experimental-zvfh -target-feature -experimental-zawrs -target-feature -experimental-ztso -target-feature +relax -target-feature -save-restore -target-abi ilp32f -msmall-data-limit 8 -mllvm -treat-scalable-fixed-error-as-warning -debugger-tuning=gdb -v -ffunction-sections -fdata-sections -fcoverage-compilation-dir=/home/eecs/nicolas.a.castaneda/vortex2/tests/opencl/matmul -resource-dir /scratch/nicolas.a.castaneda/build/llvm-vortex/lib/clang/16 -O3 -fdebug-compilation-dir=/home/eecs/nicolas.a.castaneda/vortex2/tests/opencl/matmul -ferror-limit 19 -fno-signed-char -fgnuc-version=4.2.1 -vectorize-loops -vectorize-slp -target-feature +vortex -faddrsig -o /home/eecs/nicolas.a.castaneda/.cache/pocl/kcache/tempfile_ySArAn.so.o -x ir /home/eecs/nicolas.a.castaneda/.cache/pocl/kcache/PH/OJHLLAIOAHLNICJFIGMMKLAIJOPDBOGOODMAO/matmul/0-0-0/parallel.bc
clang -cc1 version 16.0.6 based upon LLVM 16.0.6 default target riscv32-unknown-elf
warning: overriding the module target triple with riscv32-unknown-unknown-elf [-Woverride-module]
*** DivergenceTracker::initialize(): _pocl_kernel_matmul
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent data dependency:
  %mul3.i.i = mul i32 %18, %8
*** divergent data dependency:
  %add6.i.i = add i32 %mul3.i.i, %16
*** divergent data dependency:
  %24 = mul i32 %3, %add6.i.i
*** divergent data dependency:
  %mul.i = mul i32 %add6.i.i, %3
*** divergent data dependency:
  %51 = add i32 %mul.i, %add.i.i
*** divergent data dependency:
  %44 = add i32 %mul.i, %add.i.i
*** divergent data dependency:
  %add5.i.us = add i32 %28, %mul.i
*** divergent data dependency:
  %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
*** divergent data dependency:
  %29 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
*** divergent data dependency:
  store float %29, ptr %4, align 4, !tbaa !34
*** divergent data dependency:
  %.sink9 = phi i32 [ %51, %for.cond.cleanup.loopexit.btr.i ], [ %44, %for.cond.cleanup.loopexit.i ], [ %add.i.i, %10 ]
*** divergent data dependency:
  %52 = getelementptr inbounds float, ptr %2, i32 %.sink9
*** divergent data dependency:
  store float %.lcssa.lcssa.sink, ptr %52, align 4, !tbaa !34
*** divergent data dependency:
  %25 = shl i32 %24, 2
*** divergent data dependency:
  %uglygep8 = getelementptr i8, ptr %0, i32 %25
*** divergent data dependency:
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
*** divergent data dependency:
  %46 = load float, ptr %lsr.iv9, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %26
*** divergent data dependency:
  store float %46, ptr %4, align 4, !tbaa !34
*** divergent data dependency:
  %mul.i.i = mul i32 %.fr, %7
*** divergent data dependency:
  %add.i.i = add i32 %mul.i.i, %14
*** divergent data dependency:
  %21 = shl i32 %add.i.i, 2
*** divergent data dependency:
  %add11.i.us = add i32 %mul10.i.us, %add.i.i
*** divergent data dependency:
  %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
*** divergent data dependency:
  %30 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
*** divergent data dependency:
  store float %30, ptr %5, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep5 = getelementptr i8, ptr %1, i32 %21
*** divergent data dependency:
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
*** divergent data dependency:
  %47 = load float, ptr %lsr.iv6, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %23
*** divergent data dependency:
  store float %47, ptr %5, align 4, !tbaa !34
*** divergent data dependency:
  %17 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
*** divergent data dependency:
  %15 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
*** divergent data dependency:
  %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
*** divergent data dependency:
  %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
*** divergent data dependency:
  %12 = load i32, ptr %11, align 4
*** divergent data dependency:
  %.fr = freeze i32 %12
*** divergent data dependency:
  %26 = shl i32 %.fr, 2
*** divergent data dependency:
  %22 = mul i32 %.fr, %3
*** divergent data dependency:
  %27 = shl i32 %.fr, 2
*** divergent data dependency:
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %41 = add nsw i32 %28, %.fr
*** divergent data dependency:
  %add28.i = add i32 %45, %.fr
*** divergent data dependency:
  %cmp1758.i = icmp sgt i32 %.fr, 0
*** divergent data dependency:
  br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader
*** divergent sync dependency
  %.lcssa.lcssa.sink = phi float [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i ], [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ 0.000000e+00, %10 ]
*** divergent data dependency:
  %cmp.i = icmp ult i32 %add28.i, %3
*** divergent data dependency:
  %45 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
*** divergent data dependency:
  br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40
*** divergent data dependency:
  %28 = phi i32 [ %41, %for.cond.cleanup18.loopexit.i.us ], [ 0, %for.body.prebarrier.i.us.preheader ]
*** divergent data dependency:
  %43 = icmp ult i32 %41, %3
*** divergent data dependency:
  br i1 %43, label %for.body.prebarrier.i.us, label %for.cond.cleanup.loopexit.btr.i, !llvm.loop !40
*** divergent sync dependency
  %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ]
*** divergent data dependency:
  %mul10.i.us = mul i32 %28, %3
*** divergent data dependency:
  %lsr.iv.next = add i32 %lsr.iv, -1
*** divergent data dependency:
  %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
*** divergent data dependency:
  br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38
*** divergent data dependency:
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %27
*** divergent data dependency:
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %37 = load float, ptr %lsr.iv2, align 4, !tbaa !34
*** divergent data dependency:
  %23 = shl i32 %22, 2
*** divergent data dependency:
  %14 = load i32, ptr %13, align 4
*** divergent data dependency:
  %16 = load i32, ptr %15, align 4
*** divergent data dependency:
  %18 = load i32, ptr %17, align 4
*** divergent data dependency:
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %36 = load float, ptr %lsr.iv3, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
*** divergent data dependency:
  %cmp61.not.i = icmp eq i32 %3, 0
*** divergent data dependency:
  br i1 %cmp61.not.i, label %matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
*** divergent data dependency:
  %.lcssa = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ]
*** divergent data dependency:
  %34 = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ]

After divergence analysis on _pocl_kernel_matmul:
DIVERGENT: ptr %0
DIVERGENT: ptr %1
DIVERGENT: ptr %2
DIVERGENT: i32 %3
DIVERGENT: ptr %4
DIVERGENT: ptr %5
DIVERGENT: ptr %6
DIVERGENT: i32 %7
DIVERGENT: i32 %8
DIVERGENT: i32 %9

           :
DIVERGENT:       %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
DIVERGENT:       %12 = load i32, ptr %11, align 4
DIVERGENT:       %.fr = freeze i32 %12
DIVERGENT:       %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
DIVERGENT:       %14 = load i32, ptr %13, align 4
DIVERGENT:       %mul.i.i = mul i32 %.fr, %7
DIVERGENT:       %add.i.i = add i32 %mul.i.i, %14
DIVERGENT:       %cmp61.not.i = icmp eq i32 %3, 0
DIVERGENT:       br i1 %cmp61.not.i, label %matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i

           for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i:
DIVERGENT:       %15 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
DIVERGENT:       %16 = load i32, ptr %15, align 4
DIVERGENT:       %17 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
DIVERGENT:       %18 = load i32, ptr %17, align 4
DIVERGENT:       %19 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %19) #2
DIVERGENT:       %mul3.i.i = mul i32 %18, %8
DIVERGENT:       %add6.i.i = add i32 %mul3.i.i, %16
DIVERGENT:       %mul.i = mul i32 %add6.i.i, %3
DIVERGENT:       %cmp1758.i = icmp sgt i32 %.fr, 0
DIVERGENT:       %20 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %20) #2
DIVERGENT:       br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader

           for.body.prebarrier.i.preheader:
DIVERGENT:       %21 = shl i32 %add.i.i, 2
DIVERGENT:       %uglygep5 = getelementptr i8, ptr %1, i32 %21
DIVERGENT:       %22 = mul i32 %.fr, %3
DIVERGENT:       %23 = shl i32 %22, 2
DIVERGENT:       %24 = mul i32 %3, %add6.i.i
DIVERGENT:       %25 = shl i32 %24, 2
DIVERGENT:       %uglygep8 = getelementptr i8, ptr %0, i32 %25
DIVERGENT:       %26 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i

           for.body.prebarrier.i.us.preheader:
DIVERGENT:       %27 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.us

           for.body.prebarrier.i.us:
DIVERGENT:       %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ]
DIVERGENT:       %28 = phi i32 [ %41, %for.cond.cleanup18.loopexit.i.us ], [ 0, %for.body.prebarrier.i.us.preheader ]
DIVERGENT:       %add5.i.us = add i32 %28, %mul.i
DIVERGENT:       %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
DIVERGENT:       %29 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
DIVERGENT:       store float %29, ptr %4, align 4, !tbaa !34
DIVERGENT:       %mul10.i.us = mul i32 %28, %3
DIVERGENT:       %add11.i.us = add i32 %mul10.i.us, %add.i.i
DIVERGENT:       %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
DIVERGENT:       %30 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
DIVERGENT:       store float %30, ptr %5, align 4, !tbaa !34
DIVERGENT:       %31 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %31) #2
DIVERGENT:       %32 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %32) #2
DIVERGENT:       %33 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %33) #2
                 br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us

           for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us:
DIVERGENT:       %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
DIVERGENT:       %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
DIVERGENT:       %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
DIVERGENT:       %34 = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]
DIVERGENT:       %35 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %35) #2
DIVERGENT:       %36 = load float, ptr %lsr.iv3, align 4, !tbaa !34
DIVERGENT:       %37 = load float, ptr %lsr.iv2, align 4, !tbaa !34
DIVERGENT:       %38 = tail call float @llvm.fmuladd.f32(float %36, float %37, float %34)
DIVERGENT:       %39 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %39) #2
DIVERGENT:       %lsr.iv.next = add i32 %lsr.iv, -1
DIVERGENT:       %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %27
DIVERGENT:       %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
DIVERGENT:       %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
DIVERGENT:       br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38

           for.cond.cleanup18.loopexit.i.us:
DIVERGENT:       %.lcssa = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ]
DIVERGENT:       %40 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %40) #2
DIVERGENT:       %41 = add nsw i32 %28, %.fr
DIVERGENT:       %42 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %42) #2
DIVERGENT:       %43 = icmp ult i32 %41, %3
DIVERGENT:       br i1 %43, label %for.body.prebarrier.i.us, label %for.cond.cleanup.loopexit.btr.i, !llvm.loop !40

           for.cond.cleanup.loopexit.i:
DIVERGENT:       %44 = add i32 %mul.i, %add.i.i
                 br label %matmul.exit

           for.body.prebarrier.i:
DIVERGENT:       %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
DIVERGENT:       %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
DIVERGENT:       %45 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
DIVERGENT:       %46 = load float, ptr %lsr.iv9, align 4, !tbaa !34
DIVERGENT:       store float %46, ptr %4, align 4, !tbaa !34
DIVERGENT:       %47 = load float, ptr %lsr.iv6, align 4, !tbaa !34
DIVERGENT:       store float %47, ptr %5, align 4, !tbaa !34
DIVERGENT:       %48 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %48) #2
DIVERGENT:       %49 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %49) #2
DIVERGENT:       %add28.i = add i32 %45, %.fr
DIVERGENT:       %50 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %50) #2
DIVERGENT:       %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %23
DIVERGENT:       %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %26
DIVERGENT:       %cmp.i = icmp ult i32 %add28.i, %3
DIVERGENT:       br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40

           for.cond.cleanup.loopexit.btr.i:
DIVERGENT:       %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ]
DIVERGENT:       %51 = add i32 %mul.i, %add.i.i
                 br label %matmul.exit

           matmul.exit:
DIVERGENT:       %.sink9 = phi i32 [ %51, %for.cond.cleanup.loopexit.btr.i ], [ %44, %for.cond.cleanup.loopexit.i ], [ %add.i.i, %10 ]
DIVERGENT:       %.lcssa.lcssa.sink = phi float [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i ], [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ 0.000000e+00, %10 ]
DIVERGENT:       %52 = getelementptr inbounds float, ptr %2, i32 %.sink9
DIVERGENT:       store float %.lcssa.lcssa.sink, ptr %52, align 4, !tbaa !34
                 ret void

*** Vortex Divergent Branch Handling Pass0 ***
*** before Pass0 changes!
; Function Attrs: alwaysinline norecurse nounwind
define void @_pocl_kernel_matmul(ptr nocapture noundef readonly align 4 %0, ptr nocapture noundef readonly align 4 %1, ptr nocapture noundef writeonly align 4 %2, i32 noundef %3, ptr nocapture noundef align 4 %4, ptr nocapture noundef align 4 %5, ptr nocapture readonly %6, i32 %7, i32 %8, i32 %9) local_unnamed_addr #1 !kernel_arg_addr_space !28 !kernel_arg_access_qual !29 !kernel_arg_type !30 !kernel_arg_base_type !30 !kernel_arg_type_qual !31 !kernel_arg_name !32 !pocl_generated !33 {
  %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
  %12 = load i32, ptr %11, align 4
  %.fr = freeze i32 %12
  %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load i32, ptr %13, align 4
  %mul.i.i = mul i32 %.fr, %7
  %add.i.i = add i32 %mul.i.i, %14
  %cmp61.not.i = icmp eq i32 %3, 0
  br i1 %cmp61.not.i, label %matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i

for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i: ; preds = %10
  %15 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
  %16 = load i32, ptr %15, align 4
  %17 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
  %18 = load i32, ptr %17, align 4
  %19 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %19) #2
  %mul3.i.i = mul i32 %18, %8
  %add6.i.i = add i32 %mul3.i.i, %16
  %mul.i = mul i32 %add6.i.i, %3
  %cmp1758.i = icmp sgt i32 %.fr, 0
  %20 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %20) #2
  br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader

for.body.prebarrier.i.preheader:                  ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
  %21 = shl i32 %add.i.i, 2
  %uglygep5 = getelementptr i8, ptr %1, i32 %21
  %22 = mul i32 %.fr, %3
  %23 = shl i32 %22, 2
  %24 = mul i32 %3, %add6.i.i
  %25 = shl i32 %24, 2
  %uglygep8 = getelementptr i8, ptr %0, i32 %25
  %26 = shl i32 %.fr, 2
  br label %for.body.prebarrier.i

for.body.prebarrier.i.us.preheader:               ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
  %27 = shl i32 %.fr, 2
  br label %for.body.prebarrier.i.us

for.body.prebarrier.i.us:                         ; preds = %for.body.prebarrier.i.us.preheader, %for.cond.cleanup18.loopexit.i.us
  %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ]
  %28 = phi i32 [ %41, %for.cond.cleanup18.loopexit.i.us ], [ 0, %for.body.prebarrier.i.us.preheader ]
  %add5.i.us = add i32 %28, %mul.i
  %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
  %29 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
  store float %29, ptr %4, align 4, !tbaa !34
  %mul10.i.us = mul i32 %28, %3
  %add11.i.us = add i32 %mul10.i.us, %add.i.i
  %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
  %30 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
  store float %30, ptr %5, align 4, !tbaa !34
  %31 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %31) #2
  %32 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %32) #2
  %33 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %33) #2
  br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us

for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us: ; preds = %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, %for.body.prebarrier.i.us
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
  %34 = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]
  %35 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %35) #2
  %36 = load float, ptr %lsr.iv3, align 4, !tbaa !34
  %37 = load float, ptr %lsr.iv2, align 4, !tbaa !34
  %38 = tail call float @llvm.fmuladd.f32(float %36, float %37, float %34)
  %39 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %39) #2
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %27
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
  %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38

for.cond.cleanup18.loopexit.i.us:                 ; preds = %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us
  %.lcssa = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ]
  %40 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %40) #2
  %41 = add nsw i32 %28, %.fr
  %42 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %42) #2
  %43 = icmp ult i32 %41, %3
  br i1 %43, label %for.body.prebarrier.i.us, label %for.cond.cleanup.loopexit.btr.i, !llvm.loop !40

for.cond.cleanup.loopexit.i:                      ; preds = %for.body.prebarrier.i
  %44 = add i32 %mul.i, %add.i.i
  br label %matmul.exit

for.body.prebarrier.i:                            ; preds = %for.body.prebarrier.i.preheader, %for.body.prebarrier.i
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
  %45 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
  %46 = load float, ptr %lsr.iv9, align 4, !tbaa !34
  store float %46, ptr %4, align 4, !tbaa !34
  %47 = load float, ptr %lsr.iv6, align 4, !tbaa !34
  store float %47, ptr %5, align 4, !tbaa !34
  %48 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %48) #2
  %49 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %49) #2
  %add28.i = add i32 %45, %.fr
  %50 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %50) #2
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %23
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %26
  %cmp.i = icmp ult i32 %add28.i, %3
  br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40

for.cond.cleanup.loopexit.btr.i:                  ; preds = %for.cond.cleanup18.loopexit.i.us
  %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ]
  %51 = add i32 %mul.i, %add.i.i
  br label %matmul.exit

matmul.exit:                                      ; preds = %for.cond.cleanup.loopexit.btr.i, %for.cond.cleanup.loopexit.i, %10
  %.sink9 = phi i32 [ %51, %for.cond.cleanup.loopexit.btr.i ], [ %44, %for.cond.cleanup.loopexit.i ], [ %add.i.i, %10 ]
  %.lcssa.lcssa.sink = phi float [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i ], [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ 0.000000e+00, %10 ]
  %52 = getelementptr inbounds float, ptr %2, i32 %.sink9
  store float %.lcssa.lcssa.sink, ptr %52, align 4, !tbaa !34
  ret void
}

*** DivergenceTracker::initialize(): _pocl_kernel_matmul
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent data dependency:
  %mul3.i.i = mul i32 %18, %8
*** divergent data dependency:
  %add6.i.i = add i32 %mul3.i.i, %16
*** divergent data dependency:
  %24 = mul i32 %3, %add6.i.i
*** divergent data dependency:
  %mul.i = mul i32 %add6.i.i, %3
*** divergent data dependency:
  %51 = add i32 %mul.i, %add.i.i
*** divergent data dependency:
  %44 = add i32 %mul.i, %add.i.i
*** divergent data dependency:
  %add5.i.us = add i32 %28, %mul.i
*** divergent data dependency:
  %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
*** divergent data dependency:
  %29 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
*** divergent data dependency:
  store float %29, ptr %4, align 4, !tbaa !34
*** divergent data dependency:
  %.sink9 = phi i32 [ %51, %for.cond.cleanup.loopexit.btr.i ], [ %44, %for.cond.cleanup.loopexit.i ], [ %add.i.i, %10 ]
*** divergent data dependency:
  %52 = getelementptr inbounds float, ptr %2, i32 %.sink9
*** divergent data dependency:
  store float %.lcssa.lcssa.sink, ptr %52, align 4, !tbaa !34
*** divergent data dependency:
  %25 = shl i32 %24, 2
*** divergent data dependency:
  %uglygep8 = getelementptr i8, ptr %0, i32 %25
*** divergent data dependency:
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
*** divergent data dependency:
  %46 = load float, ptr %lsr.iv9, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %26
*** divergent data dependency:
  store float %46, ptr %4, align 4, !tbaa !34
*** divergent data dependency:
  %mul.i.i = mul i32 %.fr, %7
*** divergent data dependency:
  %add.i.i = add i32 %mul.i.i, %14
*** divergent data dependency:
  %21 = shl i32 %add.i.i, 2
*** divergent data dependency:
  %add11.i.us = add i32 %mul10.i.us, %add.i.i
*** divergent data dependency:
  %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
*** divergent data dependency:
  %30 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
*** divergent data dependency:
  store float %30, ptr %5, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep5 = getelementptr i8, ptr %1, i32 %21
*** divergent data dependency:
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
*** divergent data dependency:
  %47 = load float, ptr %lsr.iv6, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %23
*** divergent data dependency:
  store float %47, ptr %5, align 4, !tbaa !34
*** divergent data dependency:
  %17 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
*** divergent data dependency:
  %15 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
*** divergent data dependency:
  %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
*** divergent data dependency:
  %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
*** divergent data dependency:
  %12 = load i32, ptr %11, align 4
*** divergent data dependency:
  %.fr = freeze i32 %12
*** divergent data dependency:
  %26 = shl i32 %.fr, 2
*** divergent data dependency:
  %22 = mul i32 %.fr, %3
*** divergent data dependency:
  %27 = shl i32 %.fr, 2
*** divergent data dependency:
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %41 = add nsw i32 %28, %.fr
*** divergent data dependency:
  %add28.i = add i32 %45, %.fr
*** divergent data dependency:
  %cmp1758.i = icmp sgt i32 %.fr, 0
*** divergent data dependency:
  br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader
*** divergent sync dependency
  %.lcssa.lcssa.sink = phi float [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i ], [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ 0.000000e+00, %10 ]
*** divergent data dependency:
  %cmp.i = icmp ult i32 %add28.i, %3
*** divergent data dependency:
  %45 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
*** divergent data dependency:
  br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40
*** divergent data dependency:
  %28 = phi i32 [ %41, %for.cond.cleanup18.loopexit.i.us ], [ 0, %for.body.prebarrier.i.us.preheader ]
*** divergent data dependency:
  %43 = icmp ult i32 %41, %3
*** divergent data dependency:
  br i1 %43, label %for.body.prebarrier.i.us, label %for.cond.cleanup.loopexit.btr.i, !llvm.loop !40
*** divergent sync dependency
  %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ]
*** divergent data dependency:
  %mul10.i.us = mul i32 %28, %3
*** divergent data dependency:
  %lsr.iv.next = add i32 %lsr.iv, -1
*** divergent data dependency:
  %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
*** divergent data dependency:
  br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38
*** divergent data dependency:
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %27
*** divergent data dependency:
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %37 = load float, ptr %lsr.iv2, align 4, !tbaa !34
*** divergent data dependency:
  %23 = shl i32 %22, 2
*** divergent data dependency:
  %14 = load i32, ptr %13, align 4
*** divergent data dependency:
  %16 = load i32, ptr %15, align 4
*** divergent data dependency:
  %18 = load i32, ptr %17, align 4
*** divergent data dependency:
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %36 = load float, ptr %lsr.iv3, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
*** divergent data dependency:
  %cmp61.not.i = icmp eq i32 %3, 0
*** divergent data dependency:
  br i1 %cmp61.not.i, label %matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
*** divergent data dependency:
  %.lcssa = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ]
*** divergent data dependency:
  %34 = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ]

After divergence analysis on _pocl_kernel_matmul:
DIVERGENT: ptr %0
DIVERGENT: ptr %1
DIVERGENT: ptr %2
DIVERGENT: i32 %3
DIVERGENT: ptr %4
DIVERGENT: ptr %5
DIVERGENT: ptr %6
DIVERGENT: i32 %7
DIVERGENT: i32 %8
DIVERGENT: i32 %9

           :
DIVERGENT:       %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
DIVERGENT:       %12 = load i32, ptr %11, align 4
DIVERGENT:       %.fr = freeze i32 %12
DIVERGENT:       %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
DIVERGENT:       %14 = load i32, ptr %13, align 4
DIVERGENT:       %mul.i.i = mul i32 %.fr, %7
DIVERGENT:       %add.i.i = add i32 %mul.i.i, %14
DIVERGENT:       %cmp61.not.i = icmp eq i32 %3, 0
DIVERGENT:       br i1 %cmp61.not.i, label %matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i

           for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i:
DIVERGENT:       %15 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
DIVERGENT:       %16 = load i32, ptr %15, align 4
DIVERGENT:       %17 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
DIVERGENT:       %18 = load i32, ptr %17, align 4
DIVERGENT:       %19 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %19) #2
DIVERGENT:       %mul3.i.i = mul i32 %18, %8
DIVERGENT:       %add6.i.i = add i32 %mul3.i.i, %16
DIVERGENT:       %mul.i = mul i32 %add6.i.i, %3
DIVERGENT:       %cmp1758.i = icmp sgt i32 %.fr, 0
DIVERGENT:       %20 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %20) #2
DIVERGENT:       br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader

           for.body.prebarrier.i.preheader:
DIVERGENT:       %21 = shl i32 %add.i.i, 2
DIVERGENT:       %uglygep5 = getelementptr i8, ptr %1, i32 %21
DIVERGENT:       %22 = mul i32 %.fr, %3
DIVERGENT:       %23 = shl i32 %22, 2
DIVERGENT:       %24 = mul i32 %3, %add6.i.i
DIVERGENT:       %25 = shl i32 %24, 2
DIVERGENT:       %uglygep8 = getelementptr i8, ptr %0, i32 %25
DIVERGENT:       %26 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i

           for.body.prebarrier.i.us.preheader:
DIVERGENT:       %27 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.us

           for.body.prebarrier.i.us:
DIVERGENT:       %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ]
DIVERGENT:       %28 = phi i32 [ %41, %for.cond.cleanup18.loopexit.i.us ], [ 0, %for.body.prebarrier.i.us.preheader ]
DIVERGENT:       %add5.i.us = add i32 %28, %mul.i
DIVERGENT:       %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
DIVERGENT:       %29 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
DIVERGENT:       store float %29, ptr %4, align 4, !tbaa !34
DIVERGENT:       %mul10.i.us = mul i32 %28, %3
DIVERGENT:       %add11.i.us = add i32 %mul10.i.us, %add.i.i
DIVERGENT:       %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
DIVERGENT:       %30 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
DIVERGENT:       store float %30, ptr %5, align 4, !tbaa !34
DIVERGENT:       %31 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %31) #2
DIVERGENT:       %32 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %32) #2
DIVERGENT:       %33 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %33) #2
                 br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us

           for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us:
DIVERGENT:       %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
DIVERGENT:       %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
DIVERGENT:       %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
DIVERGENT:       %34 = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]
DIVERGENT:       %35 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %35) #2
DIVERGENT:       %36 = load float, ptr %lsr.iv3, align 4, !tbaa !34
DIVERGENT:       %37 = load float, ptr %lsr.iv2, align 4, !tbaa !34
DIVERGENT:       %38 = tail call float @llvm.fmuladd.f32(float %36, float %37, float %34)
DIVERGENT:       %39 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %39) #2
DIVERGENT:       %lsr.iv.next = add i32 %lsr.iv, -1
DIVERGENT:       %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %27
DIVERGENT:       %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
DIVERGENT:       %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
DIVERGENT:       br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38

           for.cond.cleanup18.loopexit.i.us:
DIVERGENT:       %.lcssa = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ]
DIVERGENT:       %40 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %40) #2
DIVERGENT:       %41 = add nsw i32 %28, %.fr
DIVERGENT:       %42 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %42) #2
DIVERGENT:       %43 = icmp ult i32 %41, %3
DIVERGENT:       br i1 %43, label %for.body.prebarrier.i.us, label %for.cond.cleanup.loopexit.btr.i, !llvm.loop !40

           for.cond.cleanup.loopexit.i:
DIVERGENT:       %44 = add i32 %mul.i, %add.i.i
                 br label %matmul.exit

           for.body.prebarrier.i:
DIVERGENT:       %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
DIVERGENT:       %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
DIVERGENT:       %45 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
DIVERGENT:       %46 = load float, ptr %lsr.iv9, align 4, !tbaa !34
DIVERGENT:       store float %46, ptr %4, align 4, !tbaa !34
DIVERGENT:       %47 = load float, ptr %lsr.iv6, align 4, !tbaa !34
DIVERGENT:       store float %47, ptr %5, align 4, !tbaa !34
DIVERGENT:       %48 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %48) #2
DIVERGENT:       %49 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %49) #2
DIVERGENT:       %add28.i = add i32 %45, %.fr
DIVERGENT:       %50 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %50) #2
DIVERGENT:       %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %23
DIVERGENT:       %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %26
DIVERGENT:       %cmp.i = icmp ult i32 %add28.i, %3
DIVERGENT:       br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40

           for.cond.cleanup.loopexit.btr.i:
DIVERGENT:       %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ]
DIVERGENT:       %51 = add i32 %mul.i, %add.i.i
                 br label %matmul.exit

           matmul.exit:
DIVERGENT:       %.sink9 = phi i32 [ %51, %for.cond.cleanup.loopexit.btr.i ], [ %44, %for.cond.cleanup.loopexit.i ], [ %add.i.i, %10 ]
DIVERGENT:       %.lcssa.lcssa.sink = phi float [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i ], [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ 0.000000e+00, %10 ]
DIVERGENT:       %52 = getelementptr inbounds float, ptr %2, i32 %.sink9
DIVERGENT:       store float %.lcssa.lcssa.sink, ptr %52, align 4, !tbaa !34
                 ret void

*** DivergenceTracker::initialize(): _pocl_kernel_matmul
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent data dependency:
  %mul3.i.i = mul i32 %18, %8
*** divergent data dependency:
  %add6.i.i = add i32 %mul3.i.i, %16
*** divergent data dependency:
  %24 = mul i32 %3, %add6.i.i
*** divergent data dependency:
  %mul.i = mul i32 %add6.i.i, %3
*** divergent data dependency:
  %51 = add i32 %mul.i, %add.i.i
*** divergent data dependency:
  %44 = add i32 %mul.i, %add.i.i
*** divergent data dependency:
  %add5.i.us = add i32 %28, %mul.i
*** divergent data dependency:
  %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
*** divergent data dependency:
  %29 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
*** divergent data dependency:
  store float %29, ptr %4, align 4, !tbaa !34
*** divergent data dependency:
  %.sink9 = phi i32 [ %51, %for.cond.cleanup.loopexit.btr.i ], [ %44, %for.cond.cleanup.loopexit.i ], [ %add.i.i, %10 ]
*** divergent data dependency:
  %52 = getelementptr inbounds float, ptr %2, i32 %.sink9
*** divergent data dependency:
  store float %.lcssa.lcssa.sink, ptr %52, align 4, !tbaa !34
*** divergent data dependency:
  %25 = shl i32 %24, 2
*** divergent data dependency:
  %uglygep8 = getelementptr i8, ptr %0, i32 %25
*** divergent data dependency:
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
*** divergent data dependency:
  %46 = load float, ptr %lsr.iv9, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %26
*** divergent data dependency:
  store float %46, ptr %4, align 4, !tbaa !34
*** divergent data dependency:
  %mul.i.i = mul i32 %.fr, %7
*** divergent data dependency:
  %add.i.i = add i32 %mul.i.i, %14
*** divergent data dependency:
  %21 = shl i32 %add.i.i, 2
*** divergent data dependency:
  %add11.i.us = add i32 %mul10.i.us, %add.i.i
*** divergent data dependency:
  %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
*** divergent data dependency:
  %30 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
*** divergent data dependency:
  store float %30, ptr %5, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep5 = getelementptr i8, ptr %1, i32 %21
*** divergent data dependency:
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
*** divergent data dependency:
  %47 = load float, ptr %lsr.iv6, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %23
*** divergent data dependency:
  store float %47, ptr %5, align 4, !tbaa !34
*** divergent data dependency:
  %17 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
*** divergent data dependency:
  %15 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
*** divergent data dependency:
  %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
*** divergent data dependency:
  %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
*** divergent data dependency:
  %12 = load i32, ptr %11, align 4
*** divergent data dependency:
  %.fr = freeze i32 %12
*** divergent data dependency:
  %26 = shl i32 %.fr, 2
*** divergent data dependency:
  %22 = mul i32 %.fr, %3
*** divergent data dependency:
  %27 = shl i32 %.fr, 2
*** divergent data dependency:
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %41 = add nsw i32 %28, %.fr
*** divergent data dependency:
  %add28.i = add i32 %45, %.fr
*** divergent data dependency:
  %cmp1758.i = icmp sgt i32 %.fr, 0
*** divergent data dependency:
  br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader
*** divergent sync dependency
  %.lcssa.lcssa.sink = phi float [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i ], [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ 0.000000e+00, %10 ]
*** divergent data dependency:
  %cmp.i = icmp ult i32 %add28.i, %3
*** divergent data dependency:
  %45 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
*** divergent data dependency:
  br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40
*** divergent data dependency:
  %28 = phi i32 [ %41, %for.cond.cleanup18.loopexit.i.us ], [ 0, %for.body.prebarrier.i.us.preheader ]
*** divergent data dependency:
  %43 = icmp ult i32 %41, %3
*** divergent data dependency:
  br i1 %43, label %for.body.prebarrier.i.us, label %for.cond.cleanup.loopexit.btr.i, !llvm.loop !40
*** divergent sync dependency
  %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ]
*** divergent data dependency:
  %mul10.i.us = mul i32 %28, %3
*** divergent data dependency:
  %lsr.iv.next = add i32 %lsr.iv, -1
*** divergent data dependency:
  %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
*** divergent data dependency:
  br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38
*** divergent data dependency:
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %27
*** divergent data dependency:
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %37 = load float, ptr %lsr.iv2, align 4, !tbaa !34
*** divergent data dependency:
  %23 = shl i32 %22, 2
*** divergent data dependency:
  %14 = load i32, ptr %13, align 4
*** divergent data dependency:
  %16 = load i32, ptr %15, align 4
*** divergent data dependency:
  %18 = load i32, ptr %17, align 4
*** divergent data dependency:
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %36 = load float, ptr %lsr.iv3, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
*** divergent data dependency:
  %cmp61.not.i = icmp eq i32 %3, 0
*** divergent data dependency:
  br i1 %cmp61.not.i, label %matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
*** divergent data dependency:
  %.lcssa = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ]
*** divergent data dependency:
  %34 = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ]

After divergence analysis on _pocl_kernel_matmul:
DIVERGENT: ptr %0
DIVERGENT: ptr %1
DIVERGENT: ptr %2
DIVERGENT: i32 %3
DIVERGENT: ptr %4
DIVERGENT: ptr %5
DIVERGENT: ptr %6
DIVERGENT: i32 %7
DIVERGENT: i32 %8
DIVERGENT: i32 %9

           :
DIVERGENT:       %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
DIVERGENT:       %12 = load i32, ptr %11, align 4
DIVERGENT:       %.fr = freeze i32 %12
DIVERGENT:       %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
DIVERGENT:       %14 = load i32, ptr %13, align 4
DIVERGENT:       %mul.i.i = mul i32 %.fr, %7
DIVERGENT:       %add.i.i = add i32 %mul.i.i, %14
DIVERGENT:       %cmp61.not.i = icmp eq i32 %3, 0
DIVERGENT:       br i1 %cmp61.not.i, label %matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i

           for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i:
DIVERGENT:       %15 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
DIVERGENT:       %16 = load i32, ptr %15, align 4
DIVERGENT:       %17 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
DIVERGENT:       %18 = load i32, ptr %17, align 4
DIVERGENT:       %19 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %19) #2
DIVERGENT:       %mul3.i.i = mul i32 %18, %8
DIVERGENT:       %add6.i.i = add i32 %mul3.i.i, %16
DIVERGENT:       %mul.i = mul i32 %add6.i.i, %3
DIVERGENT:       %cmp1758.i = icmp sgt i32 %.fr, 0
DIVERGENT:       %20 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %20) #2
DIVERGENT:       br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader

           for.body.prebarrier.i.preheader:
DIVERGENT:       %21 = shl i32 %add.i.i, 2
DIVERGENT:       %uglygep5 = getelementptr i8, ptr %1, i32 %21
DIVERGENT:       %22 = mul i32 %.fr, %3
DIVERGENT:       %23 = shl i32 %22, 2
DIVERGENT:       %24 = mul i32 %3, %add6.i.i
DIVERGENT:       %25 = shl i32 %24, 2
DIVERGENT:       %uglygep8 = getelementptr i8, ptr %0, i32 %25
DIVERGENT:       %26 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i

           for.body.prebarrier.i.us.preheader:
DIVERGENT:       %27 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.us

           for.body.prebarrier.i.us:
DIVERGENT:       %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ]
DIVERGENT:       %28 = phi i32 [ %41, %for.cond.cleanup18.loopexit.i.us ], [ 0, %for.body.prebarrier.i.us.preheader ]
DIVERGENT:       %add5.i.us = add i32 %28, %mul.i
DIVERGENT:       %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
DIVERGENT:       %29 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
DIVERGENT:       store float %29, ptr %4, align 4, !tbaa !34
DIVERGENT:       %mul10.i.us = mul i32 %28, %3
DIVERGENT:       %add11.i.us = add i32 %mul10.i.us, %add.i.i
DIVERGENT:       %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
DIVERGENT:       %30 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
DIVERGENT:       store float %30, ptr %5, align 4, !tbaa !34
DIVERGENT:       %31 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %31) #2
DIVERGENT:       %32 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %32) #2
DIVERGENT:       %33 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %33) #2
                 br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us

           for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us:
DIVERGENT:       %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
DIVERGENT:       %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
DIVERGENT:       %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
DIVERGENT:       %34 = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]
DIVERGENT:       %35 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %35) #2
DIVERGENT:       %36 = load float, ptr %lsr.iv3, align 4, !tbaa !34
DIVERGENT:       %37 = load float, ptr %lsr.iv2, align 4, !tbaa !34
DIVERGENT:       %38 = tail call float @llvm.fmuladd.f32(float %36, float %37, float %34)
DIVERGENT:       %39 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %39) #2
DIVERGENT:       %lsr.iv.next = add i32 %lsr.iv, -1
DIVERGENT:       %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %27
DIVERGENT:       %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
DIVERGENT:       %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
DIVERGENT:       br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38

           for.cond.cleanup18.loopexit.i.us:
DIVERGENT:       %.lcssa = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ]
DIVERGENT:       %40 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %40) #2
DIVERGENT:       %41 = add nsw i32 %28, %.fr
DIVERGENT:       %42 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %42) #2
DIVERGENT:       %43 = icmp ult i32 %41, %3
DIVERGENT:       br i1 %43, label %for.body.prebarrier.i.us, label %for.cond.cleanup.loopexit.btr.i, !llvm.loop !40

           for.cond.cleanup.loopexit.i:
DIVERGENT:       %44 = add i32 %mul.i, %add.i.i
                 br label %matmul.exit

           for.body.prebarrier.i:
DIVERGENT:       %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
DIVERGENT:       %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
DIVERGENT:       %45 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
DIVERGENT:       %46 = load float, ptr %lsr.iv9, align 4, !tbaa !34
DIVERGENT:       store float %46, ptr %4, align 4, !tbaa !34
DIVERGENT:       %47 = load float, ptr %lsr.iv6, align 4, !tbaa !34
DIVERGENT:       store float %47, ptr %5, align 4, !tbaa !34
DIVERGENT:       %48 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %48) #2
DIVERGENT:       %49 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %49) #2
DIVERGENT:       %add28.i = add i32 %45, %.fr
DIVERGENT:       %50 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %50) #2
DIVERGENT:       %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %23
DIVERGENT:       %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %26
DIVERGENT:       %cmp.i = icmp ult i32 %add28.i, %3
DIVERGENT:       br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40

           for.cond.cleanup.loopexit.btr.i:
DIVERGENT:       %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.us ]
DIVERGENT:       %51 = add i32 %mul.i, %add.i.i
                 br label %matmul.exit

           matmul.exit:
DIVERGENT:       %.sink9 = phi i32 [ %51, %for.cond.cleanup.loopexit.btr.i ], [ %44, %for.cond.cleanup.loopexit.i ], [ %add.i.i, %10 ]
DIVERGENT:       %.lcssa.lcssa.sink = phi float [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i ], [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ 0.000000e+00, %10 ]
DIVERGENT:       %52 = getelementptr inbounds float, ptr %2, i32 %.sink9
DIVERGENT:       store float %.lcssa.lcssa.sink, ptr %52, align 4, !tbaa !34
                 ret void

*** structurize: skip divergent complete region for.body.prebarrier.i => for.cond.cleanup.loopexit.i
*** structurize: skip divergent complete region for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us => for.cond.cleanup18.loopexit.i.us
*** structurize: divergent non-regional block: for.body.prebarrier.i.us => for.cond.cleanup.loopexit.btr.i
Visiting: for.body.prebarrier.i.us
Visiting: SubRegion with entry: for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us
Visiting: for.cond.cleanup18.loopexit.i.us
*** structurize: skip divergent complete region for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i => matmul.exit
*** structurize: skip divergent complete region %10 => matmul.exit
*** DivergenceTracker::initialize(): _pocl_kernel_matmul
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent data dependency:
  %mul3.i.i = mul i32 %18, %8
*** divergent data dependency:
  %add6.i.i = add i32 %mul3.i.i, %16
*** divergent data dependency:
  %24 = mul i32 %3, %add6.i.i
*** divergent data dependency:
  %mul.i = mul i32 %add6.i.i, %3
*** divergent data dependency:
  %51 = add i32 %mul.i, %add.i.i
*** divergent data dependency:
  %44 = add i32 %mul.i, %add.i.i
*** divergent data dependency:
  %add5.i.us = add i32 %28, %mul.i
*** divergent data dependency:
  %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
*** divergent data dependency:
  %29 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
*** divergent data dependency:
  store float %29, ptr %4, align 4, !tbaa !34
*** divergent data dependency:
  %.sink9 = phi i32 [ %51, %for.cond.cleanup.loopexit.btr.i ], [ %44, %for.cond.cleanup.loopexit.i ], [ %add.i.i, %10 ]
*** divergent data dependency:
  %52 = getelementptr inbounds float, ptr %2, i32 %.sink9
*** divergent data dependency:
  store float %.lcssa.lcssa.sink, ptr %52, align 4, !tbaa !34
*** divergent data dependency:
  %25 = shl i32 %24, 2
*** divergent data dependency:
  %uglygep8 = getelementptr i8, ptr %0, i32 %25
*** divergent data dependency:
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
*** divergent data dependency:
  %46 = load float, ptr %lsr.iv9, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %26
*** divergent data dependency:
  store float %46, ptr %4, align 4, !tbaa !34
*** divergent data dependency:
  %mul.i.i = mul i32 %.fr, %7
*** divergent data dependency:
  %add.i.i = add i32 %mul.i.i, %14
*** divergent data dependency:
  %21 = shl i32 %add.i.i, 2
*** divergent data dependency:
  %add11.i.us = add i32 %mul10.i.us, %add.i.i
*** divergent data dependency:
  %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
*** divergent data dependency:
  %30 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
*** divergent data dependency:
  store float %30, ptr %5, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep5 = getelementptr i8, ptr %1, i32 %21
*** divergent data dependency:
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
*** divergent data dependency:
  %47 = load float, ptr %lsr.iv6, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %23
*** divergent data dependency:
  store float %47, ptr %5, align 4, !tbaa !34
*** divergent data dependency:
  %17 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
*** divergent data dependency:
  %15 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
*** divergent data dependency:
  %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
*** divergent data dependency:
  %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
*** divergent data dependency:
  %12 = load i32, ptr %11, align 4
*** divergent data dependency:
  %.fr = freeze i32 %12
*** divergent data dependency:
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %26 = shl i32 %.fr, 2
*** divergent data dependency:
  %22 = mul i32 %.fr, %3
*** divergent data dependency:
  %27 = shl i32 %.fr, 2
*** divergent data dependency:
  %41 = add nsw i32 %28, %.fr
*** divergent data dependency:
  %add28.i = add i32 %45, %.fr
*** divergent data dependency:
  %cmp1758.i = icmp sgt i32 %.fr, 0
*** divergent data dependency:
  br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader
*** divergent sync dependency
  %.lcssa.lcssa.sink = phi float [ %38, %for.cond.cleanup.loopexit.btr.i ], [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ 0.000000e+00, %10 ]
*** divergent data dependency:
  %cmp.i = icmp ult i32 %add28.i, %3
*** divergent data dependency:
  %45 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
*** divergent data dependency:
  br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40
*** divergent data dependency:
  %28 = phi i32 [ 0, %for.body.prebarrier.i.us.preheader ], [ %41, %for.cond.cleanup18.loopexit.i.us ]
*** divergent data dependency:
  %43 = icmp uge i32 %41, %3
*** divergent data dependency:
  br i1 %43, label %for.cond.cleanup.loopexit.btr.i, label %for.body.prebarrier.i.us
*** divergent data dependency:
  %mul10.i.us = mul i32 %28, %3
*** divergent data dependency:
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %27
*** divergent data dependency:
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %37 = load float, ptr %lsr.iv2, align 4, !tbaa !34
*** divergent data dependency:
  %23 = shl i32 %22, 2
*** divergent data dependency:
  %lsr.iv.next = add i32 %lsr.iv, -1
*** divergent data dependency:
  %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
*** divergent data dependency:
  br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38
*** divergent data dependency:
  %14 = load i32, ptr %13, align 4
*** divergent data dependency:
  %16 = load i32, ptr %15, align 4
*** divergent data dependency:
  %18 = load i32, ptr %17, align 4
*** divergent data dependency:
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
*** divergent data dependency:
  %36 = load float, ptr %lsr.iv3, align 4, !tbaa !34
*** divergent data dependency:
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
*** divergent data dependency:
  %cmp61.not.i = icmp eq i32 %3, 0
*** divergent data dependency:
  br i1 %cmp61.not.i, label %matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
*** divergent data dependency:
  %.lcssa5.us = phi float [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ], [ %38, %for.cond.cleanup18.loopexit.i.us ]
*** divergent data dependency:
  %34 = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]

After divergence analysis on _pocl_kernel_matmul:
DIVERGENT: ptr %0
DIVERGENT: ptr %1
DIVERGENT: ptr %2
DIVERGENT: i32 %3
DIVERGENT: ptr %4
DIVERGENT: ptr %5
DIVERGENT: ptr %6
DIVERGENT: i32 %7
DIVERGENT: i32 %8
DIVERGENT: i32 %9

           :
DIVERGENT:       %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
DIVERGENT:       %12 = load i32, ptr %11, align 4
DIVERGENT:       %.fr = freeze i32 %12
DIVERGENT:       %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
DIVERGENT:       %14 = load i32, ptr %13, align 4
DIVERGENT:       %mul.i.i = mul i32 %.fr, %7
DIVERGENT:       %add.i.i = add i32 %mul.i.i, %14
DIVERGENT:       %cmp61.not.i = icmp eq i32 %3, 0
DIVERGENT:       br i1 %cmp61.not.i, label %matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i

           for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i:
DIVERGENT:       %15 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
DIVERGENT:       %16 = load i32, ptr %15, align 4
DIVERGENT:       %17 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
DIVERGENT:       %18 = load i32, ptr %17, align 4
DIVERGENT:       %19 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %19) #2
DIVERGENT:       %mul3.i.i = mul i32 %18, %8
DIVERGENT:       %add6.i.i = add i32 %mul3.i.i, %16
DIVERGENT:       %mul.i = mul i32 %add6.i.i, %3
DIVERGENT:       %cmp1758.i = icmp sgt i32 %.fr, 0
DIVERGENT:       %20 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %20) #2
DIVERGENT:       br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader

           for.body.prebarrier.i.preheader:
DIVERGENT:       %21 = shl i32 %add.i.i, 2
DIVERGENT:       %uglygep5 = getelementptr i8, ptr %1, i32 %21
DIVERGENT:       %22 = mul i32 %.fr, %3
DIVERGENT:       %23 = shl i32 %22, 2
DIVERGENT:       %24 = mul i32 %3, %add6.i.i
DIVERGENT:       %25 = shl i32 %24, 2
DIVERGENT:       %uglygep8 = getelementptr i8, ptr %0, i32 %25
DIVERGENT:       %26 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i

           for.body.prebarrier.i.us.preheader:
DIVERGENT:       %27 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.us

           for.body.prebarrier.i.us:
DIVERGENT:       %.lcssa5.us = phi float [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ], [ %38, %for.cond.cleanup18.loopexit.i.us ]
DIVERGENT:       %28 = phi i32 [ 0, %for.body.prebarrier.i.us.preheader ], [ %41, %for.cond.cleanup18.loopexit.i.us ]
DIVERGENT:       %add5.i.us = add i32 %28, %mul.i
DIVERGENT:       %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
DIVERGENT:       %29 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
DIVERGENT:       store float %29, ptr %4, align 4, !tbaa !34
DIVERGENT:       %mul10.i.us = mul i32 %28, %3
DIVERGENT:       %add11.i.us = add i32 %mul10.i.us, %add.i.i
DIVERGENT:       %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
DIVERGENT:       %30 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
DIVERGENT:       store float %30, ptr %5, align 4, !tbaa !34
DIVERGENT:       %31 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %31) #2
DIVERGENT:       %32 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %32) #2
DIVERGENT:       %33 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %33) #2
                 br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us

           for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us:
DIVERGENT:       %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
DIVERGENT:       %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
DIVERGENT:       %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
DIVERGENT:       %34 = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]
DIVERGENT:       %35 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %35) #2
DIVERGENT:       %36 = load float, ptr %lsr.iv3, align 4, !tbaa !34
DIVERGENT:       %37 = load float, ptr %lsr.iv2, align 4, !tbaa !34
DIVERGENT:       %38 = tail call float @llvm.fmuladd.f32(float %36, float %37, float %34)
DIVERGENT:       %39 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %39) #2
DIVERGENT:       %lsr.iv.next = add i32 %lsr.iv, -1
DIVERGENT:       %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %27
DIVERGENT:       %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
DIVERGENT:       %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
DIVERGENT:       br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38

           for.cond.cleanup18.loopexit.i.us:
DIVERGENT:       %40 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %40) #2
DIVERGENT:       %41 = add nsw i32 %28, %.fr
DIVERGENT:       %42 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %42) #2
DIVERGENT:       %43 = icmp uge i32 %41, %3
DIVERGENT:       br i1 %43, label %for.cond.cleanup.loopexit.btr.i, label %for.body.prebarrier.i.us

           for.cond.cleanup.loopexit.i:
DIVERGENT:       %44 = add i32 %mul.i, %add.i.i
                 br label %matmul.exit

           for.body.prebarrier.i:
DIVERGENT:       %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
DIVERGENT:       %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
DIVERGENT:       %45 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
DIVERGENT:       %46 = load float, ptr %lsr.iv9, align 4, !tbaa !34
DIVERGENT:       store float %46, ptr %4, align 4, !tbaa !34
DIVERGENT:       %47 = load float, ptr %lsr.iv6, align 4, !tbaa !34
DIVERGENT:       store float %47, ptr %5, align 4, !tbaa !34
DIVERGENT:       %48 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %48) #2
DIVERGENT:       %49 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %49) #2
DIVERGENT:       %add28.i = add i32 %45, %.fr
DIVERGENT:       %50 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %50) #2
DIVERGENT:       %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %23
DIVERGENT:       %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %26
DIVERGENT:       %cmp.i = icmp ult i32 %add28.i, %3
DIVERGENT:       br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40

           for.cond.cleanup.loopexit.btr.i:
DIVERGENT:       %51 = add i32 %mul.i, %add.i.i
                 br label %matmul.exit

           matmul.exit:
DIVERGENT:       %.sink9 = phi i32 [ %51, %for.cond.cleanup.loopexit.btr.i ], [ %44, %for.cond.cleanup.loopexit.i ], [ %add.i.i, %10 ]
DIVERGENT:       %.lcssa.lcssa.sink = phi float [ %38, %for.cond.cleanup.loopexit.btr.i ], [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ 0.000000e+00, %10 ]
DIVERGENT:       %52 = getelementptr inbounds float, ptr %2, i32 %.sink9
DIVERGENT:       store float %.lcssa.lcssa.sink, ptr %52, align 4, !tbaa !34
                 ret void

*** Vortex Divergent Branch Handling ***
*** Region info:
[0] %10 => <Function Return>
  [1] %10 => matmul.exit
    [2] for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i => matmul.exit
      [3] for.body.prebarrier.i.us => for.cond.cleanup.loopexit.btr.i
        [4] for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us => for.cond.cleanup18.loopexit.i.us
      [3] for.body.prebarrier.i => for.cond.cleanup.loopexit.i

*** divergent branch: BB.10, IPDOM=BB.matmul.exit
*** divergent branch: BB.for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i, IPDOM=BB.matmul.exit
*** skip non-conditional branch: BB.for.body.prebarrier.i.us.preheader
*** skip non-conditional branch: BB.for.body.prebarrier.i.us
*** divergent loop: BB.for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us
*** divergent loop: BB.for.body.prebarrier.i.us
*** skip non-conditional branch: BB.for.cond.cleanup.loopexit.btr.i
*** skip non-conditional branch: BB.for.body.prebarrier.i.preheader
*** divergent loop: BB.for.body.prebarrier.i
*** skip non-conditional branch: BB.for.cond.cleanup.loopexit.i
*** before changes!
; Function Attrs: alwaysinline norecurse nounwind
define void @_pocl_kernel_matmul(ptr nocapture noundef readonly align 4 %0, ptr nocapture noundef readonly align 4 %1, ptr nocapture noundef writeonly align 4 %2, i32 noundef %3, ptr nocapture noundef align 4 %4, ptr nocapture noundef align 4 %5, ptr nocapture readonly %6, i32 %7, i32 %8, i32 %9) local_unnamed_addr #1 !kernel_arg_addr_space !28 !kernel_arg_access_qual !29 !kernel_arg_type !30 !kernel_arg_base_type !30 !kernel_arg_type_qual !31 !kernel_arg_name !32 !pocl_generated !33 {
  %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
  %12 = load i32, ptr %11, align 4
  %.fr = freeze i32 %12
  %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load i32, ptr %13, align 4
  %mul.i.i = mul i32 %.fr, %7
  %add.i.i = add i32 %mul.i.i, %14
  %cmp61.not.i = icmp eq i32 %3, 0
  br i1 %cmp61.not.i, label %matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i

for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i: ; preds = %10
  %15 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
  %16 = load i32, ptr %15, align 4
  %17 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
  %18 = load i32, ptr %17, align 4
  %19 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %19) #2
  %mul3.i.i = mul i32 %18, %8
  %add6.i.i = add i32 %mul3.i.i, %16
  %mul.i = mul i32 %add6.i.i, %3
  %cmp1758.i = icmp sgt i32 %.fr, 0
  %20 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %20) #2
  br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader

for.body.prebarrier.i.preheader:                  ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
  %21 = shl i32 %add.i.i, 2
  %uglygep5 = getelementptr i8, ptr %1, i32 %21
  %22 = mul i32 %.fr, %3
  %23 = shl i32 %22, 2
  %24 = mul i32 %3, %add6.i.i
  %25 = shl i32 %24, 2
  %uglygep8 = getelementptr i8, ptr %0, i32 %25
  %26 = shl i32 %.fr, 2
  br label %for.body.prebarrier.i

for.body.prebarrier.i.us.preheader:               ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
  %27 = shl i32 %.fr, 2
  br label %for.body.prebarrier.i.us

for.body.prebarrier.i.us:                         ; preds = %for.cond.cleanup18.loopexit.i.us, %for.body.prebarrier.i.us.preheader
  %.lcssa5.us = phi float [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ], [ %38, %for.cond.cleanup18.loopexit.i.us ]
  %28 = phi i32 [ 0, %for.body.prebarrier.i.us.preheader ], [ %41, %for.cond.cleanup18.loopexit.i.us ]
  %add5.i.us = add i32 %28, %mul.i
  %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
  %29 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
  store float %29, ptr %4, align 4, !tbaa !34
  %mul10.i.us = mul i32 %28, %3
  %add11.i.us = add i32 %mul10.i.us, %add.i.i
  %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
  %30 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
  store float %30, ptr %5, align 4, !tbaa !34
  %31 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %31) #2
  %32 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %32) #2
  %33 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %33) #2
  br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us

for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us: ; preds = %for.body.prebarrier.i.us, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
  %34 = phi float [ %38, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]
  %35 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %35) #2
  %36 = load float, ptr %lsr.iv3, align 4, !tbaa !34
  %37 = load float, ptr %lsr.iv2, align 4, !tbaa !34
  %38 = tail call float @llvm.fmuladd.f32(float %36, float %37, float %34)
  %39 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %39) #2
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %27
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
  %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38

for.cond.cleanup18.loopexit.i.us:                 ; preds = %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us
  %40 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %40) #2
  %41 = add nsw i32 %28, %.fr
  %42 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %42) #2
  %43 = icmp uge i32 %41, %3
  br i1 %43, label %for.cond.cleanup.loopexit.btr.i, label %for.body.prebarrier.i.us

for.cond.cleanup.loopexit.i:                      ; preds = %for.body.prebarrier.i
  %44 = add i32 %mul.i, %add.i.i
  br label %matmul.exit

for.body.prebarrier.i:                            ; preds = %for.body.prebarrier.i.preheader, %for.body.prebarrier.i
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
  %45 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
  %46 = load float, ptr %lsr.iv9, align 4, !tbaa !34
  store float %46, ptr %4, align 4, !tbaa !34
  %47 = load float, ptr %lsr.iv6, align 4, !tbaa !34
  store float %47, ptr %5, align 4, !tbaa !34
  %48 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %48) #2
  %49 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %49) #2
  %add28.i = add i32 %45, %.fr
  %50 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %50) #2
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %23
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %26
  %cmp.i = icmp ult i32 %add28.i, %3
  br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40

for.cond.cleanup.loopexit.btr.i:                  ; preds = %for.cond.cleanup18.loopexit.i.us
  %51 = add i32 %mul.i, %add.i.i
  br label %matmul.exit

matmul.exit:                                      ; preds = %for.cond.cleanup.loopexit.btr.i, %for.cond.cleanup.loopexit.i, %10
  %.sink9 = phi i32 [ %51, %for.cond.cleanup.loopexit.btr.i ], [ %44, %for.cond.cleanup.loopexit.i ], [ %add.i.i, %10 ]
  %.lcssa.lcssa.sink = phi float [ %38, %for.cond.cleanup.loopexit.btr.i ], [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ 0.000000e+00, %10 ]
  %52 = getelementptr inbounds float, ptr %2, i32 %.sink9
  store float %.lcssa.lcssa.sink, ptr %52, align 4, !tbaa !34
  ret void
}

*** process loop: BB.for.body.prebarrier.i
*** backup thread mask 'V.tmask' before loop preheader branch: BB.for.body.prebarrier.i.preheader
*** insert thread predicate 'V.V.cmp.i.i32' before exiting block: BB.for.body.prebarrier.i
*** after predicate change!
0x55f2b524bb08
*** process loop: BB.for.body.prebarrier.i.us
*** backup thread mask 'V.tmask11' before loop preheader branch: BB.for.body.prebarrier.i.us.preheader
*** insert thread predicate 'V.V.V.43.not.i32' before exiting block: BB.for.cond.cleanup18.loopexit.i.us
*** after predicate change!
0x55f2b524bb08
*** process loop: BB.for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us
*** backup thread mask 'V.tmask12' before loop preheader branch: BB.for.body.prebarrier.i.us
*** insert thread predicate 'V.V.V.exitcond.not.i.us.not.i32' before exiting block: BB.for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us
*** after predicate change!
0x55f2b524bb08
*** process branch BB.for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i, region=for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i => matmul.exit
*** insert split 'V.V.cmp1758.i.i32' before BB.for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i's branch.
*** insert join stub 'join_stub' before BB.matmul.exit
****** replace BB.for.cond.cleanup.loopexit.i.succ[0]: BB.matmul.exit with BB.join_stub
****** replace BB.for.cond.cleanup.loopexit.btr.i.succ[0]: BB.matmul.exit with BB.join_stub
*** process branch BB.10, region=%10 => matmul.exit
*** insert split 'V.V.cmp61.not.i.i32' before BB.10's branch.
*** insert join stub 'join_stub15' before BB.matmul.exit
****** replace BB.join_stub.succ[0]: BB.matmul.exit with BB.join_stub15
****** replace BB.10.succ[0]: BB.matmul.exit with BB.join_stub15
*** after changes!
; Function Attrs: alwaysinline norecurse nounwind
define void @_pocl_kernel_matmul(ptr nocapture noundef readonly align 4 %0, ptr nocapture noundef readonly align 4 %1, ptr nocapture noundef writeonly align 4 %2, i32 noundef %3, ptr nocapture noundef align 4 %4, ptr nocapture noundef align 4 %5, ptr nocapture readonly %6, i32 %7, i32 %8, i32 %9) local_unnamed_addr #1 !kernel_arg_addr_space !28 !kernel_arg_access_qual !29 !kernel_arg_type !30 !kernel_arg_base_type !30 !kernel_arg_type_qual !31 !kernel_arg_name !32 !pocl_generated !33 {
  %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
  %12 = load i32, ptr %11, align 4
  %.fr = freeze i32 %12
  %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load i32, ptr %13, align 4
  %mul.i.i = mul i32 %.fr, %7
  %add.i.i = add i32 %mul.i.i, %14
  %cmp61.not.i = icmp eq i32 %3, 0
  %V.cmp61.not.i.i32 = zext i1 %cmp61.not.i to i32
  %15 = call i32 @llvm.riscv.vx.split.i32.i32(i32 %V.cmp61.not.i.i32)
  br i1 %cmp61.not.i, label %join_stub15, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i

for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i: ; preds = %10
  %16 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
  %17 = load i32, ptr %16, align 4
  %18 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
  %19 = load i32, ptr %18, align 4
  %20 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %20) #2
  %mul3.i.i = mul i32 %19, %8
  %add6.i.i = add i32 %mul3.i.i, %17
  %mul.i = mul i32 %add6.i.i, %3
  %cmp1758.i = icmp sgt i32 %.fr, 0
  %21 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %21) #2
  %V.cmp1758.i.i32 = zext i1 %cmp1758.i to i32
  %22 = call i32 @llvm.riscv.vx.split.i32.i32(i32 %V.cmp1758.i.i32)
  br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader

for.body.prebarrier.i.preheader:                  ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
  %23 = shl i32 %add.i.i, 2
  %uglygep5 = getelementptr i8, ptr %1, i32 %23
  %24 = mul i32 %.fr, %3
  %25 = shl i32 %24, 2
  %26 = mul i32 %3, %add6.i.i
  %27 = shl i32 %26, 2
  %uglygep8 = getelementptr i8, ptr %0, i32 %27
  %28 = shl i32 %.fr, 2
  %tmask = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body.prebarrier.i

for.body.prebarrier.i.us.preheader:               ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
  %29 = shl i32 %.fr, 2
  %tmask11 = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body.prebarrier.i.us

for.body.prebarrier.i.us:                         ; preds = %for.cond.cleanup18.loopexit.i.us, %for.body.prebarrier.i.us.preheader
  %.lcssa5.us = phi float [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ], [ %40, %for.cond.cleanup18.loopexit.i.us ]
  %30 = phi i32 [ 0, %for.body.prebarrier.i.us.preheader ], [ %43, %for.cond.cleanup18.loopexit.i.us ]
  %add5.i.us = add i32 %30, %mul.i
  %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
  %31 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
  store float %31, ptr %4, align 4, !tbaa !34
  %mul10.i.us = mul i32 %30, %3
  %add11.i.us = add i32 %mul10.i.us, %add.i.i
  %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
  %32 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
  store float %32, ptr %5, align 4, !tbaa !34
  %33 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %33) #2
  %34 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %34) #2
  %35 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %35) #2
  %tmask12 = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us

for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us: ; preds = %for.body.prebarrier.i.us, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
  %36 = phi float [ %40, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]
  %37 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %37) #2
  %38 = load float, ptr %lsr.iv3, align 4, !tbaa !34
  %39 = load float, ptr %lsr.iv2, align 4, !tbaa !34
  %40 = tail call float @llvm.fmuladd.f32(float %38, float %39, float %36)
  %41 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %41) #2
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %29
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
  %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
  %V.exitcond.not.i.us.not = xor i1 %exitcond.not.i.us, true
  %V.V.exitcond.not.i.us.not.i32 = zext i1 %V.exitcond.not.i.us.not to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.V.exitcond.not.i.us.not.i32, i32 %tmask12)
  br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38

for.cond.cleanup18.loopexit.i.us:                 ; preds = %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us
  %42 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %42) #2
  %43 = add nsw i32 %30, %.fr
  %44 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %44) #2
  %45 = icmp uge i32 %43, %3
  %V.43.not = xor i1 %45, true
  %V.V.43.not.i32 = zext i1 %V.43.not to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.V.43.not.i32, i32 %tmask11)
  br i1 %45, label %for.cond.cleanup.loopexit.btr.i, label %for.body.prebarrier.i.us

for.cond.cleanup.loopexit.i:                      ; preds = %for.body.prebarrier.i
  %46 = add i32 %mul.i, %add.i.i
  br label %join_stub

for.body.prebarrier.i:                            ; preds = %for.body.prebarrier.i.preheader, %for.body.prebarrier.i
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
  %47 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
  %48 = load float, ptr %lsr.iv9, align 4, !tbaa !34
  store float %48, ptr %4, align 4, !tbaa !34
  %49 = load float, ptr %lsr.iv6, align 4, !tbaa !34
  store float %49, ptr %5, align 4, !tbaa !34
  %50 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %50) #2
  %51 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %51) #2
  %add28.i = add i32 %47, %.fr
  %52 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %52) #2
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %25
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %28
  %cmp.i = icmp ult i32 %add28.i, %3
  %V.cmp.i.i32 = zext i1 %cmp.i to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.cmp.i.i32, i32 %tmask)
  br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40

for.cond.cleanup.loopexit.btr.i:                  ; preds = %for.cond.cleanup18.loopexit.i.us
  %53 = add i32 %mul.i, %add.i.i
  br label %join_stub

join_stub:                                        ; preds = %for.cond.cleanup.loopexit.btr.i, %for.cond.cleanup.loopexit.i
  %.lcssa.lcssa.sink14 = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ %40, %for.cond.cleanup.loopexit.btr.i ]
  %.sink913 = phi i32 [ %46, %for.cond.cleanup.loopexit.i ], [ %53, %for.cond.cleanup.loopexit.btr.i ]
  call void @llvm.riscv.vx.join.i32(i32 %22)
  br label %join_stub15

join_stub15:                                      ; preds = %10, %join_stub
  %.lcssa.lcssa.sink17 = phi float [ %.lcssa.lcssa.sink14, %join_stub ], [ 0.000000e+00, %10 ]
  %.sink916 = phi i32 [ %.sink913, %join_stub ], [ %add.i.i, %10 ]
  call void @llvm.riscv.vx.join.i32(i32 %15)
  br label %matmul.exit

matmul.exit:                                      ; preds = %join_stub15
  %.sink9 = phi i32 [ %.sink916, %join_stub15 ]
  %.lcssa.lcssa.sink = phi float [ %.lcssa.lcssa.sink17, %join_stub15 ]
  %54 = getelementptr inbounds float, ptr %2, i32 %.sink9
  store float %.lcssa.lcssa.sink, ptr %54, align 4, !tbaa !34
  ret void
}

*** DivergenceTracker::initialize(): _pocl_kernel_matmul_workgroup
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent data dependency:
  %mul3.i.i.i = mul i32 %30, %3
*** divergent data dependency:
  %add6.i.i.i = add i32 %mul3.i.i.i, %28
*** divergent data dependency:
  %36 = mul i32 %11, %add6.i.i.i
*** divergent data dependency:
  %mul.i.i = mul i32 %add6.i.i.i, %11
*** divergent data dependency:
  %63 = add i32 %mul.i.i, %add.i.i.i
*** divergent data dependency:
  %56 = add i32 %mul.i.i, %add.i.i.i
*** divergent data dependency:
  %add5.i.i.us = add i32 %40, %mul.i.i
*** divergent data dependency:
  %arrayidx.i.i.us = getelementptr inbounds float, ptr %17, i32 %add5.i.i.us
*** divergent data dependency:
  %41 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !28
*** divergent data dependency:
  store float %41, ptr %23, align 4, !tbaa !28
*** divergent data dependency:
  %.sink10 = phi i32 [ %56, %for.cond.cleanup.loopexit.i.i ], [ %63, %for.cond.cleanup.loopexit.btr.i.i ], [ %add.i.i.i, %5 ]
*** divergent data dependency:
  %64 = getelementptr inbounds float, ptr %8, i32 %.sink10
*** divergent data dependency:
  store float %.sink, ptr %64, align 4, !tbaa !28
*** divergent data dependency:
  %37 = shl i32 %36, 2
*** divergent data dependency:
  %uglygep8 = getelementptr i8, ptr %17, i32 %37
*** divergent data dependency:
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
*** divergent data dependency:
  %58 = load float, ptr %lsr.iv9, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %38
*** divergent data dependency:
  store float %58, ptr %23, align 4, !tbaa !28
*** divergent data dependency:
  %mul.i.i.i = mul i32 %.fr, %2
*** divergent data dependency:
  %add.i.i.i = add i32 %mul.i.i.i, %15
*** divergent data dependency:
  %33 = shl i32 %add.i.i.i, 2
*** divergent data dependency:
  %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
*** divergent data dependency:
  %arrayidx12.i.i.us = getelementptr inbounds float, ptr %20, i32 %add11.i.i.us
*** divergent data dependency:
  %42 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !28
*** divergent data dependency:
  store float %42, ptr %26, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep5 = getelementptr i8, ptr %20, i32 %33
*** divergent data dependency:
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
*** divergent data dependency:
  %59 = load float, ptr %lsr.iv6, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %35
*** divergent data dependency:
  store float %59, ptr %26, align 4, !tbaa !28
*** divergent data dependency:
  %29 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
*** divergent data dependency:
  %27 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
*** divergent data dependency:
  %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
*** divergent data dependency:
  %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
*** divergent data dependency:
  %13 = load i32, ptr %12, align 4
*** divergent data dependency:
  %.fr = freeze i32 %13
*** divergent data dependency:
  %38 = shl i32 %.fr, 2
*** divergent data dependency:
  %34 = mul i32 %.fr, %11
*** divergent data dependency:
  %39 = shl i32 %.fr, 2
*** divergent data dependency:
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %53 = add nsw i32 %40, %.fr
*** divergent data dependency:
  %add28.i.i = add i32 %57, %.fr
*** divergent data dependency:
  %cmp1758.i.i = icmp sgt i32 %.fr, 0
*** divergent data dependency:
  br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader
*** divergent sync dependency
  %.sink = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i.i ], [ 0.000000e+00, %5 ]
*** divergent data dependency:
  %cmp.i.i = icmp ult i32 %add28.i.i, %11
*** divergent data dependency:
  %57 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
*** divergent data dependency:
  br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !34
*** divergent data dependency:
  %40 = phi i32 [ %53, %for.cond.cleanup18.loopexit.i.i.us ], [ 0, %for.body.prebarrier.i.i.us.preheader ]
*** divergent data dependency:
  %55 = icmp ult i32 %53, %11
*** divergent data dependency:
  br i1 %55, label %for.body.prebarrier.i.i.us, label %for.cond.cleanup.loopexit.btr.i.i, !llvm.loop !34
*** divergent sync dependency
  %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ]
*** divergent data dependency:
  %mul10.i.i.us = mul i32 %40, %11
*** divergent data dependency:
  %lsr.iv.next = add i32 %lsr.iv, -1
*** divergent data dependency:
  %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
*** divergent data dependency:
  br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !32
*** divergent data dependency:
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %39
*** divergent data dependency:
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %26, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %49 = load float, ptr %lsr.iv2, align 4, !tbaa !28
*** divergent data dependency:
  %35 = shl i32 %34, 2
*** divergent data dependency:
  %15 = load i32, ptr %14, align 4
*** divergent data dependency:
  %28 = load i32, ptr %27, align 4
*** divergent data dependency:
  %30 = load i32, ptr %29, align 4
*** divergent data dependency:
  %24 = getelementptr ptr, ptr %0, i32 5
*** divergent data dependency:
  %21 = getelementptr ptr, ptr %0, i32 4
*** divergent data dependency:
  %9 = getelementptr ptr, ptr %0, i32 3
*** divergent data dependency:
  %6 = getelementptr ptr, ptr %0, i32 2
*** divergent data dependency:
  %18 = getelementptr ptr, ptr %0, i32 1
*** divergent data dependency:
  %16 = load ptr, ptr %0, align 4
*** divergent data dependency:
  %17 = load ptr, ptr %16, align 4
*** divergent data dependency:
  %19 = load ptr, ptr %18, align 4
*** divergent data dependency:
  %20 = load ptr, ptr %19, align 4
*** divergent data dependency:
  %7 = load ptr, ptr %6, align 4
*** divergent data dependency:
  %8 = load ptr, ptr %7, align 4
*** divergent data dependency:
  %10 = load ptr, ptr %9, align 4
*** divergent data dependency:
  %11 = load i32, ptr %10, align 4
*** divergent data dependency:
  %cmp61.not.i.i = icmp eq i32 %11, 0
*** divergent data dependency:
  br i1 %cmp61.not.i.i, label %_pocl_kernel_matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
*** divergent data dependency:
  %22 = load ptr, ptr %21, align 4
*** divergent data dependency:
  %23 = load ptr, ptr %22, align 4
*** divergent data dependency:
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %23, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %48 = load float, ptr %lsr.iv3, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
*** divergent data dependency:
  %25 = load ptr, ptr %24, align 4
*** divergent data dependency:
  %26 = load ptr, ptr %25, align 4
*** divergent data dependency:
  %.lcssa = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ]
*** divergent data dependency:
  %46 = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ]

After divergence analysis on _pocl_kernel_matmul_workgroup:
DIVERGENT: ptr %0
DIVERGENT: ptr %1
DIVERGENT: i32 %2
DIVERGENT: i32 %3
DIVERGENT: i32 %4

           :
DIVERGENT:       %6 = getelementptr ptr, ptr %0, i32 2
DIVERGENT:       %7 = load ptr, ptr %6, align 4
DIVERGENT:       %8 = load ptr, ptr %7, align 4
DIVERGENT:       %9 = getelementptr ptr, ptr %0, i32 3
DIVERGENT:       %10 = load ptr, ptr %9, align 4
DIVERGENT:       %11 = load i32, ptr %10, align 4
DIVERGENT:       %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
DIVERGENT:       %13 = load i32, ptr %12, align 4
DIVERGENT:       %.fr = freeze i32 %13
DIVERGENT:       %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
DIVERGENT:       %15 = load i32, ptr %14, align 4
DIVERGENT:       %mul.i.i.i = mul i32 %.fr, %2
DIVERGENT:       %add.i.i.i = add i32 %mul.i.i.i, %15
DIVERGENT:       %cmp61.not.i.i = icmp eq i32 %11, 0
DIVERGENT:       br i1 %cmp61.not.i.i, label %_pocl_kernel_matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i

           for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i:
DIVERGENT:       %16 = load ptr, ptr %0, align 4
DIVERGENT:       %17 = load ptr, ptr %16, align 4
DIVERGENT:       %18 = getelementptr ptr, ptr %0, i32 1
DIVERGENT:       %19 = load ptr, ptr %18, align 4
DIVERGENT:       %20 = load ptr, ptr %19, align 4
DIVERGENT:       %21 = getelementptr ptr, ptr %0, i32 4
DIVERGENT:       %22 = load ptr, ptr %21, align 4
DIVERGENT:       %23 = load ptr, ptr %22, align 4
DIVERGENT:       %24 = getelementptr ptr, ptr %0, i32 5
DIVERGENT:       %25 = load ptr, ptr %24, align 4
DIVERGENT:       %26 = load ptr, ptr %25, align 4
DIVERGENT:       %27 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
DIVERGENT:       %28 = load i32, ptr %27, align 4
DIVERGENT:       %29 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
DIVERGENT:       %30 = load i32, ptr %29, align 4
DIVERGENT:       %31 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %31) #2
DIVERGENT:       %mul3.i.i.i = mul i32 %30, %3
DIVERGENT:       %add6.i.i.i = add i32 %mul3.i.i.i, %28
DIVERGENT:       %mul.i.i = mul i32 %add6.i.i.i, %11
DIVERGENT:       %cmp1758.i.i = icmp sgt i32 %.fr, 0
DIVERGENT:       %32 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %32) #2
DIVERGENT:       br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader

           for.body.prebarrier.i.i.preheader:
DIVERGENT:       %33 = shl i32 %add.i.i.i, 2
DIVERGENT:       %uglygep5 = getelementptr i8, ptr %20, i32 %33
DIVERGENT:       %34 = mul i32 %.fr, %11
DIVERGENT:       %35 = shl i32 %34, 2
DIVERGENT:       %36 = mul i32 %11, %add6.i.i.i
DIVERGENT:       %37 = shl i32 %36, 2
DIVERGENT:       %uglygep8 = getelementptr i8, ptr %17, i32 %37
DIVERGENT:       %38 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.i

           for.body.prebarrier.i.i.us.preheader:
DIVERGENT:       %39 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.i.us

           for.body.prebarrier.i.i.us:
DIVERGENT:       %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ]
DIVERGENT:       %40 = phi i32 [ %53, %for.cond.cleanup18.loopexit.i.i.us ], [ 0, %for.body.prebarrier.i.i.us.preheader ]
DIVERGENT:       %add5.i.i.us = add i32 %40, %mul.i.i
DIVERGENT:       %arrayidx.i.i.us = getelementptr inbounds float, ptr %17, i32 %add5.i.i.us
DIVERGENT:       %41 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !28
DIVERGENT:       store float %41, ptr %23, align 4, !tbaa !28
DIVERGENT:       %mul10.i.i.us = mul i32 %40, %11
DIVERGENT:       %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
DIVERGENT:       %arrayidx12.i.i.us = getelementptr inbounds float, ptr %20, i32 %add11.i.i.us
DIVERGENT:       %42 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !28
DIVERGENT:       store float %42, ptr %26, align 4, !tbaa !28
DIVERGENT:       %43 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %43) #2
DIVERGENT:       %44 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %44) #2
DIVERGENT:       %45 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %45) #2
                 br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us

           for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us:
DIVERGENT:       %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %23, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %26, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %46 = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %47 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %47) #2
DIVERGENT:       %48 = load float, ptr %lsr.iv3, align 4, !tbaa !28
DIVERGENT:       %49 = load float, ptr %lsr.iv2, align 4, !tbaa !28
DIVERGENT:       %50 = tail call float @llvm.fmuladd.f32(float %48, float %49, float %46)
DIVERGENT:       %51 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %51) #2
DIVERGENT:       %lsr.iv.next = add i32 %lsr.iv, -1
DIVERGENT:       %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %39
DIVERGENT:       %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
DIVERGENT:       %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
DIVERGENT:       br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !32

           for.cond.cleanup18.loopexit.i.i.us:
DIVERGENT:       %.lcssa = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ]
DIVERGENT:       %52 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %52) #2
DIVERGENT:       %53 = add nsw i32 %40, %.fr
DIVERGENT:       %54 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %54) #2
DIVERGENT:       %55 = icmp ult i32 %53, %11
DIVERGENT:       br i1 %55, label %for.body.prebarrier.i.i.us, label %for.cond.cleanup.loopexit.btr.i.i, !llvm.loop !34

           for.cond.cleanup.loopexit.i.i:
DIVERGENT:       %56 = add i32 %mul.i.i, %add.i.i.i
                 br label %_pocl_kernel_matmul.exit

           for.body.prebarrier.i.i:
DIVERGENT:       %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
DIVERGENT:       %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
DIVERGENT:       %57 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
DIVERGENT:       %58 = load float, ptr %lsr.iv9, align 4, !tbaa !28
DIVERGENT:       store float %58, ptr %23, align 4, !tbaa !28
DIVERGENT:       %59 = load float, ptr %lsr.iv6, align 4, !tbaa !28
DIVERGENT:       store float %59, ptr %26, align 4, !tbaa !28
DIVERGENT:       %60 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %60) #2
DIVERGENT:       %61 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %61) #2
DIVERGENT:       %add28.i.i = add i32 %57, %.fr
DIVERGENT:       %62 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %62) #2
DIVERGENT:       %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %35
DIVERGENT:       %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %38
DIVERGENT:       %cmp.i.i = icmp ult i32 %add28.i.i, %11
DIVERGENT:       br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !34

           for.cond.cleanup.loopexit.btr.i.i:
DIVERGENT:       %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ]
DIVERGENT:       %63 = add i32 %mul.i.i, %add.i.i.i
                 br label %_pocl_kernel_matmul.exit

           _pocl_kernel_matmul.exit:
DIVERGENT:       %.sink10 = phi i32 [ %56, %for.cond.cleanup.loopexit.i.i ], [ %63, %for.cond.cleanup.loopexit.btr.i.i ], [ %add.i.i.i, %5 ]
DIVERGENT:       %.sink = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i.i ], [ 0.000000e+00, %5 ]
DIVERGENT:       %64 = getelementptr inbounds float, ptr %8, i32 %.sink10
DIVERGENT:       store float %.sink, ptr %64, align 4, !tbaa !28
                 ret void

*** Vortex Divergent Branch Handling Pass0 ***
*** before Pass0 changes!
; Function Attrs: nounwind
define void @_pocl_kernel_matmul_workgroup(ptr nocapture readonly %0, ptr nocapture readonly %1, i32 %2, i32 %3, i32 %4) local_unnamed_addr #2 {
  %6 = getelementptr ptr, ptr %0, i32 2
  %7 = load ptr, ptr %6, align 4
  %8 = load ptr, ptr %7, align 4
  %9 = getelementptr ptr, ptr %0, i32 3
  %10 = load ptr, ptr %9, align 4
  %11 = load i32, ptr %10, align 4
  %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
  %13 = load i32, ptr %12, align 4
  %.fr = freeze i32 %13
  %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
  %15 = load i32, ptr %14, align 4
  %mul.i.i.i = mul i32 %.fr, %2
  %add.i.i.i = add i32 %mul.i.i.i, %15
  %cmp61.not.i.i = icmp eq i32 %11, 0
  br i1 %cmp61.not.i.i, label %_pocl_kernel_matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i

for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i: ; preds = %5
  %16 = load ptr, ptr %0, align 4
  %17 = load ptr, ptr %16, align 4
  %18 = getelementptr ptr, ptr %0, i32 1
  %19 = load ptr, ptr %18, align 4
  %20 = load ptr, ptr %19, align 4
  %21 = getelementptr ptr, ptr %0, i32 4
  %22 = load ptr, ptr %21, align 4
  %23 = load ptr, ptr %22, align 4
  %24 = getelementptr ptr, ptr %0, i32 5
  %25 = load ptr, ptr %24, align 4
  %26 = load ptr, ptr %25, align 4
  %27 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
  %28 = load i32, ptr %27, align 4
  %29 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
  %30 = load i32, ptr %29, align 4
  %31 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %31) #2
  %mul3.i.i.i = mul i32 %30, %3
  %add6.i.i.i = add i32 %mul3.i.i.i, %28
  %mul.i.i = mul i32 %add6.i.i.i, %11
  %cmp1758.i.i = icmp sgt i32 %.fr, 0
  %32 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %32) #2
  br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader

for.body.prebarrier.i.i.preheader:                ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
  %33 = shl i32 %add.i.i.i, 2
  %uglygep5 = getelementptr i8, ptr %20, i32 %33
  %34 = mul i32 %.fr, %11
  %35 = shl i32 %34, 2
  %36 = mul i32 %11, %add6.i.i.i
  %37 = shl i32 %36, 2
  %uglygep8 = getelementptr i8, ptr %17, i32 %37
  %38 = shl i32 %.fr, 2
  br label %for.body.prebarrier.i.i

for.body.prebarrier.i.i.us.preheader:             ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
  %39 = shl i32 %.fr, 2
  br label %for.body.prebarrier.i.i.us

for.body.prebarrier.i.i.us:                       ; preds = %for.body.prebarrier.i.i.us.preheader, %for.cond.cleanup18.loopexit.i.i.us
  %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ]
  %40 = phi i32 [ %53, %for.cond.cleanup18.loopexit.i.i.us ], [ 0, %for.body.prebarrier.i.i.us.preheader ]
  %add5.i.i.us = add i32 %40, %mul.i.i
  %arrayidx.i.i.us = getelementptr inbounds float, ptr %17, i32 %add5.i.i.us
  %41 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !34
  store float %41, ptr %23, align 4, !tbaa !34
  %mul10.i.i.us = mul i32 %40, %11
  %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
  %arrayidx12.i.i.us = getelementptr inbounds float, ptr %20, i32 %add11.i.i.us
  %42 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !34
  store float %42, ptr %26, align 4, !tbaa !34
  %43 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %43) #2
  %44 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %44) #2
  %45 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %45) #2
  br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us

for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us: ; preds = %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, %for.body.prebarrier.i.i.us
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %23, %for.body.prebarrier.i.i.us ]
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %26, %for.body.prebarrier.i.i.us ]
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
  %46 = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]
  %47 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %47) #2
  %48 = load float, ptr %lsr.iv3, align 4, !tbaa !34
  %49 = load float, ptr %lsr.iv2, align 4, !tbaa !34
  %50 = tail call float @llvm.fmuladd.f32(float %48, float %49, float %46)
  %51 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %51) #2
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %39
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
  %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !38

for.cond.cleanup18.loopexit.i.i.us:               ; preds = %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us
  %.lcssa = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ]
  %52 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %52) #2
  %53 = add nsw i32 %40, %.fr
  %54 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %54) #2
  %55 = icmp ult i32 %53, %11
  br i1 %55, label %for.body.prebarrier.i.i.us, label %for.cond.cleanup.loopexit.btr.i.i, !llvm.loop !40

for.cond.cleanup.loopexit.i.i:                    ; preds = %for.body.prebarrier.i.i
  %56 = add i32 %mul.i.i, %add.i.i.i
  br label %_pocl_kernel_matmul.exit

for.body.prebarrier.i.i:                          ; preds = %for.body.prebarrier.i.i.preheader, %for.body.prebarrier.i.i
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
  %57 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
  %58 = load float, ptr %lsr.iv9, align 4, !tbaa !34
  store float %58, ptr %23, align 4, !tbaa !34
  %59 = load float, ptr %lsr.iv6, align 4, !tbaa !34
  store float %59, ptr %26, align 4, !tbaa !34
  %60 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %60) #2
  %61 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %61) #2
  %add28.i.i = add i32 %57, %.fr
  %62 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %62) #2
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %35
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %38
  %cmp.i.i = icmp ult i32 %add28.i.i, %11
  br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !40

for.cond.cleanup.loopexit.btr.i.i:                ; preds = %for.cond.cleanup18.loopexit.i.i.us
  %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ]
  %63 = add i32 %mul.i.i, %add.i.i.i
  br label %_pocl_kernel_matmul.exit

_pocl_kernel_matmul.exit:                         ; preds = %for.cond.cleanup.loopexit.btr.i.i, %for.cond.cleanup.loopexit.i.i, %5
  %.sink10 = phi i32 [ %56, %for.cond.cleanup.loopexit.i.i ], [ %63, %for.cond.cleanup.loopexit.btr.i.i ], [ %add.i.i.i, %5 ]
  %.sink = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i.i ], [ 0.000000e+00, %5 ]
  %64 = getelementptr inbounds float, ptr %8, i32 %.sink10
  store float %.sink, ptr %64, align 4, !tbaa !34
  ret void
}

*** DivergenceTracker::initialize(): _pocl_kernel_matmul_workgroup
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent data dependency:
  %mul3.i.i.i = mul i32 %30, %3
*** divergent data dependency:
  %add6.i.i.i = add i32 %mul3.i.i.i, %28
*** divergent data dependency:
  %36 = mul i32 %11, %add6.i.i.i
*** divergent data dependency:
  %mul.i.i = mul i32 %add6.i.i.i, %11
*** divergent data dependency:
  %63 = add i32 %mul.i.i, %add.i.i.i
*** divergent data dependency:
  %56 = add i32 %mul.i.i, %add.i.i.i
*** divergent data dependency:
  %add5.i.i.us = add i32 %40, %mul.i.i
*** divergent data dependency:
  %arrayidx.i.i.us = getelementptr inbounds float, ptr %17, i32 %add5.i.i.us
*** divergent data dependency:
  %41 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !28
*** divergent data dependency:
  store float %41, ptr %23, align 4, !tbaa !28
*** divergent data dependency:
  %.sink10 = phi i32 [ %56, %for.cond.cleanup.loopexit.i.i ], [ %63, %for.cond.cleanup.loopexit.btr.i.i ], [ %add.i.i.i, %5 ]
*** divergent data dependency:
  %64 = getelementptr inbounds float, ptr %8, i32 %.sink10
*** divergent data dependency:
  store float %.sink, ptr %64, align 4, !tbaa !28
*** divergent data dependency:
  %37 = shl i32 %36, 2
*** divergent data dependency:
  %uglygep8 = getelementptr i8, ptr %17, i32 %37
*** divergent data dependency:
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
*** divergent data dependency:
  %58 = load float, ptr %lsr.iv9, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %38
*** divergent data dependency:
  store float %58, ptr %23, align 4, !tbaa !28
*** divergent data dependency:
  %mul.i.i.i = mul i32 %.fr, %2
*** divergent data dependency:
  %add.i.i.i = add i32 %mul.i.i.i, %15
*** divergent data dependency:
  %33 = shl i32 %add.i.i.i, 2
*** divergent data dependency:
  %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
*** divergent data dependency:
  %arrayidx12.i.i.us = getelementptr inbounds float, ptr %20, i32 %add11.i.i.us
*** divergent data dependency:
  %42 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !28
*** divergent data dependency:
  store float %42, ptr %26, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep5 = getelementptr i8, ptr %20, i32 %33
*** divergent data dependency:
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
*** divergent data dependency:
  %59 = load float, ptr %lsr.iv6, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %35
*** divergent data dependency:
  store float %59, ptr %26, align 4, !tbaa !28
*** divergent data dependency:
  %29 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
*** divergent data dependency:
  %27 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
*** divergent data dependency:
  %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
*** divergent data dependency:
  %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
*** divergent data dependency:
  %13 = load i32, ptr %12, align 4
*** divergent data dependency:
  %.fr = freeze i32 %13
*** divergent data dependency:
  %38 = shl i32 %.fr, 2
*** divergent data dependency:
  %34 = mul i32 %.fr, %11
*** divergent data dependency:
  %39 = shl i32 %.fr, 2
*** divergent data dependency:
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %53 = add nsw i32 %40, %.fr
*** divergent data dependency:
  %add28.i.i = add i32 %57, %.fr
*** divergent data dependency:
  %cmp1758.i.i = icmp sgt i32 %.fr, 0
*** divergent data dependency:
  br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader
*** divergent sync dependency
  %.sink = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i.i ], [ 0.000000e+00, %5 ]
*** divergent data dependency:
  %cmp.i.i = icmp ult i32 %add28.i.i, %11
*** divergent data dependency:
  %57 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
*** divergent data dependency:
  br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !34
*** divergent data dependency:
  %40 = phi i32 [ %53, %for.cond.cleanup18.loopexit.i.i.us ], [ 0, %for.body.prebarrier.i.i.us.preheader ]
*** divergent data dependency:
  %55 = icmp ult i32 %53, %11
*** divergent data dependency:
  br i1 %55, label %for.body.prebarrier.i.i.us, label %for.cond.cleanup.loopexit.btr.i.i, !llvm.loop !34
*** divergent sync dependency
  %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ]
*** divergent data dependency:
  %mul10.i.i.us = mul i32 %40, %11
*** divergent data dependency:
  %lsr.iv.next = add i32 %lsr.iv, -1
*** divergent data dependency:
  %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
*** divergent data dependency:
  br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !32
*** divergent data dependency:
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %39
*** divergent data dependency:
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %26, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %49 = load float, ptr %lsr.iv2, align 4, !tbaa !28
*** divergent data dependency:
  %35 = shl i32 %34, 2
*** divergent data dependency:
  %15 = load i32, ptr %14, align 4
*** divergent data dependency:
  %28 = load i32, ptr %27, align 4
*** divergent data dependency:
  %30 = load i32, ptr %29, align 4
*** divergent data dependency:
  %24 = getelementptr ptr, ptr %0, i32 5
*** divergent data dependency:
  %21 = getelementptr ptr, ptr %0, i32 4
*** divergent data dependency:
  %9 = getelementptr ptr, ptr %0, i32 3
*** divergent data dependency:
  %6 = getelementptr ptr, ptr %0, i32 2
*** divergent data dependency:
  %18 = getelementptr ptr, ptr %0, i32 1
*** divergent data dependency:
  %16 = load ptr, ptr %0, align 4
*** divergent data dependency:
  %17 = load ptr, ptr %16, align 4
*** divergent data dependency:
  %19 = load ptr, ptr %18, align 4
*** divergent data dependency:
  %20 = load ptr, ptr %19, align 4
*** divergent data dependency:
  %7 = load ptr, ptr %6, align 4
*** divergent data dependency:
  %8 = load ptr, ptr %7, align 4
*** divergent data dependency:
  %10 = load ptr, ptr %9, align 4
*** divergent data dependency:
  %11 = load i32, ptr %10, align 4
*** divergent data dependency:
  %cmp61.not.i.i = icmp eq i32 %11, 0
*** divergent data dependency:
  br i1 %cmp61.not.i.i, label %_pocl_kernel_matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
*** divergent data dependency:
  %22 = load ptr, ptr %21, align 4
*** divergent data dependency:
  %23 = load ptr, ptr %22, align 4
*** divergent data dependency:
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %23, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %48 = load float, ptr %lsr.iv3, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
*** divergent data dependency:
  %25 = load ptr, ptr %24, align 4
*** divergent data dependency:
  %26 = load ptr, ptr %25, align 4
*** divergent data dependency:
  %.lcssa = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ]
*** divergent data dependency:
  %46 = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ]

After divergence analysis on _pocl_kernel_matmul_workgroup:
DIVERGENT: ptr %0
DIVERGENT: ptr %1
DIVERGENT: i32 %2
DIVERGENT: i32 %3
DIVERGENT: i32 %4

           :
DIVERGENT:       %6 = getelementptr ptr, ptr %0, i32 2
DIVERGENT:       %7 = load ptr, ptr %6, align 4
DIVERGENT:       %8 = load ptr, ptr %7, align 4
DIVERGENT:       %9 = getelementptr ptr, ptr %0, i32 3
DIVERGENT:       %10 = load ptr, ptr %9, align 4
DIVERGENT:       %11 = load i32, ptr %10, align 4
DIVERGENT:       %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
DIVERGENT:       %13 = load i32, ptr %12, align 4
DIVERGENT:       %.fr = freeze i32 %13
DIVERGENT:       %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
DIVERGENT:       %15 = load i32, ptr %14, align 4
DIVERGENT:       %mul.i.i.i = mul i32 %.fr, %2
DIVERGENT:       %add.i.i.i = add i32 %mul.i.i.i, %15
DIVERGENT:       %cmp61.not.i.i = icmp eq i32 %11, 0
DIVERGENT:       br i1 %cmp61.not.i.i, label %_pocl_kernel_matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i

           for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i:
DIVERGENT:       %16 = load ptr, ptr %0, align 4
DIVERGENT:       %17 = load ptr, ptr %16, align 4
DIVERGENT:       %18 = getelementptr ptr, ptr %0, i32 1
DIVERGENT:       %19 = load ptr, ptr %18, align 4
DIVERGENT:       %20 = load ptr, ptr %19, align 4
DIVERGENT:       %21 = getelementptr ptr, ptr %0, i32 4
DIVERGENT:       %22 = load ptr, ptr %21, align 4
DIVERGENT:       %23 = load ptr, ptr %22, align 4
DIVERGENT:       %24 = getelementptr ptr, ptr %0, i32 5
DIVERGENT:       %25 = load ptr, ptr %24, align 4
DIVERGENT:       %26 = load ptr, ptr %25, align 4
DIVERGENT:       %27 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
DIVERGENT:       %28 = load i32, ptr %27, align 4
DIVERGENT:       %29 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
DIVERGENT:       %30 = load i32, ptr %29, align 4
DIVERGENT:       %31 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %31) #2
DIVERGENT:       %mul3.i.i.i = mul i32 %30, %3
DIVERGENT:       %add6.i.i.i = add i32 %mul3.i.i.i, %28
DIVERGENT:       %mul.i.i = mul i32 %add6.i.i.i, %11
DIVERGENT:       %cmp1758.i.i = icmp sgt i32 %.fr, 0
DIVERGENT:       %32 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %32) #2
DIVERGENT:       br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader

           for.body.prebarrier.i.i.preheader:
DIVERGENT:       %33 = shl i32 %add.i.i.i, 2
DIVERGENT:       %uglygep5 = getelementptr i8, ptr %20, i32 %33
DIVERGENT:       %34 = mul i32 %.fr, %11
DIVERGENT:       %35 = shl i32 %34, 2
DIVERGENT:       %36 = mul i32 %11, %add6.i.i.i
DIVERGENT:       %37 = shl i32 %36, 2
DIVERGENT:       %uglygep8 = getelementptr i8, ptr %17, i32 %37
DIVERGENT:       %38 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.i

           for.body.prebarrier.i.i.us.preheader:
DIVERGENT:       %39 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.i.us

           for.body.prebarrier.i.i.us:
DIVERGENT:       %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ]
DIVERGENT:       %40 = phi i32 [ %53, %for.cond.cleanup18.loopexit.i.i.us ], [ 0, %for.body.prebarrier.i.i.us.preheader ]
DIVERGENT:       %add5.i.i.us = add i32 %40, %mul.i.i
DIVERGENT:       %arrayidx.i.i.us = getelementptr inbounds float, ptr %17, i32 %add5.i.i.us
DIVERGENT:       %41 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !28
DIVERGENT:       store float %41, ptr %23, align 4, !tbaa !28
DIVERGENT:       %mul10.i.i.us = mul i32 %40, %11
DIVERGENT:       %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
DIVERGENT:       %arrayidx12.i.i.us = getelementptr inbounds float, ptr %20, i32 %add11.i.i.us
DIVERGENT:       %42 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !28
DIVERGENT:       store float %42, ptr %26, align 4, !tbaa !28
DIVERGENT:       %43 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %43) #2
DIVERGENT:       %44 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %44) #2
DIVERGENT:       %45 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %45) #2
                 br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us

           for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us:
DIVERGENT:       %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %23, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %26, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %46 = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %47 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %47) #2
DIVERGENT:       %48 = load float, ptr %lsr.iv3, align 4, !tbaa !28
DIVERGENT:       %49 = load float, ptr %lsr.iv2, align 4, !tbaa !28
DIVERGENT:       %50 = tail call float @llvm.fmuladd.f32(float %48, float %49, float %46)
DIVERGENT:       %51 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %51) #2
DIVERGENT:       %lsr.iv.next = add i32 %lsr.iv, -1
DIVERGENT:       %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %39
DIVERGENT:       %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
DIVERGENT:       %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
DIVERGENT:       br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !32

           for.cond.cleanup18.loopexit.i.i.us:
DIVERGENT:       %.lcssa = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ]
DIVERGENT:       %52 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %52) #2
DIVERGENT:       %53 = add nsw i32 %40, %.fr
DIVERGENT:       %54 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %54) #2
DIVERGENT:       %55 = icmp ult i32 %53, %11
DIVERGENT:       br i1 %55, label %for.body.prebarrier.i.i.us, label %for.cond.cleanup.loopexit.btr.i.i, !llvm.loop !34

           for.cond.cleanup.loopexit.i.i:
DIVERGENT:       %56 = add i32 %mul.i.i, %add.i.i.i
                 br label %_pocl_kernel_matmul.exit

           for.body.prebarrier.i.i:
DIVERGENT:       %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
DIVERGENT:       %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
DIVERGENT:       %57 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
DIVERGENT:       %58 = load float, ptr %lsr.iv9, align 4, !tbaa !28
DIVERGENT:       store float %58, ptr %23, align 4, !tbaa !28
DIVERGENT:       %59 = load float, ptr %lsr.iv6, align 4, !tbaa !28
DIVERGENT:       store float %59, ptr %26, align 4, !tbaa !28
DIVERGENT:       %60 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %60) #2
DIVERGENT:       %61 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %61) #2
DIVERGENT:       %add28.i.i = add i32 %57, %.fr
DIVERGENT:       %62 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %62) #2
DIVERGENT:       %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %35
DIVERGENT:       %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %38
DIVERGENT:       %cmp.i.i = icmp ult i32 %add28.i.i, %11
DIVERGENT:       br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !34

           for.cond.cleanup.loopexit.btr.i.i:
DIVERGENT:       %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ]
DIVERGENT:       %63 = add i32 %mul.i.i, %add.i.i.i
                 br label %_pocl_kernel_matmul.exit

           _pocl_kernel_matmul.exit:
DIVERGENT:       %.sink10 = phi i32 [ %56, %for.cond.cleanup.loopexit.i.i ], [ %63, %for.cond.cleanup.loopexit.btr.i.i ], [ %add.i.i.i, %5 ]
DIVERGENT:       %.sink = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i.i ], [ 0.000000e+00, %5 ]
DIVERGENT:       %64 = getelementptr inbounds float, ptr %8, i32 %.sink10
DIVERGENT:       store float %.sink, ptr %64, align 4, !tbaa !28
                 ret void

*** DivergenceTracker::initialize(): _pocl_kernel_matmul_workgroup
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent data dependency:
  %mul3.i.i.i = mul i32 %30, %3
*** divergent data dependency:
  %add6.i.i.i = add i32 %mul3.i.i.i, %28
*** divergent data dependency:
  %36 = mul i32 %11, %add6.i.i.i
*** divergent data dependency:
  %mul.i.i = mul i32 %add6.i.i.i, %11
*** divergent data dependency:
  %63 = add i32 %mul.i.i, %add.i.i.i
*** divergent data dependency:
  %56 = add i32 %mul.i.i, %add.i.i.i
*** divergent data dependency:
  %add5.i.i.us = add i32 %40, %mul.i.i
*** divergent data dependency:
  %arrayidx.i.i.us = getelementptr inbounds float, ptr %17, i32 %add5.i.i.us
*** divergent data dependency:
  %41 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !28
*** divergent data dependency:
  store float %41, ptr %23, align 4, !tbaa !28
*** divergent data dependency:
  %.sink10 = phi i32 [ %56, %for.cond.cleanup.loopexit.i.i ], [ %63, %for.cond.cleanup.loopexit.btr.i.i ], [ %add.i.i.i, %5 ]
*** divergent data dependency:
  %64 = getelementptr inbounds float, ptr %8, i32 %.sink10
*** divergent data dependency:
  store float %.sink, ptr %64, align 4, !tbaa !28
*** divergent data dependency:
  %37 = shl i32 %36, 2
*** divergent data dependency:
  %uglygep8 = getelementptr i8, ptr %17, i32 %37
*** divergent data dependency:
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
*** divergent data dependency:
  %58 = load float, ptr %lsr.iv9, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %38
*** divergent data dependency:
  store float %58, ptr %23, align 4, !tbaa !28
*** divergent data dependency:
  %mul.i.i.i = mul i32 %.fr, %2
*** divergent data dependency:
  %add.i.i.i = add i32 %mul.i.i.i, %15
*** divergent data dependency:
  %33 = shl i32 %add.i.i.i, 2
*** divergent data dependency:
  %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
*** divergent data dependency:
  %arrayidx12.i.i.us = getelementptr inbounds float, ptr %20, i32 %add11.i.i.us
*** divergent data dependency:
  %42 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !28
*** divergent data dependency:
  store float %42, ptr %26, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep5 = getelementptr i8, ptr %20, i32 %33
*** divergent data dependency:
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
*** divergent data dependency:
  %59 = load float, ptr %lsr.iv6, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %35
*** divergent data dependency:
  store float %59, ptr %26, align 4, !tbaa !28
*** divergent data dependency:
  %29 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
*** divergent data dependency:
  %27 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
*** divergent data dependency:
  %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
*** divergent data dependency:
  %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
*** divergent data dependency:
  %13 = load i32, ptr %12, align 4
*** divergent data dependency:
  %.fr = freeze i32 %13
*** divergent data dependency:
  %38 = shl i32 %.fr, 2
*** divergent data dependency:
  %34 = mul i32 %.fr, %11
*** divergent data dependency:
  %39 = shl i32 %.fr, 2
*** divergent data dependency:
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %53 = add nsw i32 %40, %.fr
*** divergent data dependency:
  %add28.i.i = add i32 %57, %.fr
*** divergent data dependency:
  %cmp1758.i.i = icmp sgt i32 %.fr, 0
*** divergent data dependency:
  br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader
*** divergent sync dependency
  %.sink = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i.i ], [ 0.000000e+00, %5 ]
*** divergent data dependency:
  %cmp.i.i = icmp ult i32 %add28.i.i, %11
*** divergent data dependency:
  %57 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
*** divergent data dependency:
  br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !34
*** divergent data dependency:
  %40 = phi i32 [ %53, %for.cond.cleanup18.loopexit.i.i.us ], [ 0, %for.body.prebarrier.i.i.us.preheader ]
*** divergent data dependency:
  %55 = icmp ult i32 %53, %11
*** divergent data dependency:
  br i1 %55, label %for.body.prebarrier.i.i.us, label %for.cond.cleanup.loopexit.btr.i.i, !llvm.loop !34
*** divergent sync dependency
  %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ]
*** divergent data dependency:
  %mul10.i.i.us = mul i32 %40, %11
*** divergent data dependency:
  %lsr.iv.next = add i32 %lsr.iv, -1
*** divergent data dependency:
  %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
*** divergent data dependency:
  br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !32
*** divergent data dependency:
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %39
*** divergent data dependency:
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %26, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %49 = load float, ptr %lsr.iv2, align 4, !tbaa !28
*** divergent data dependency:
  %35 = shl i32 %34, 2
*** divergent data dependency:
  %15 = load i32, ptr %14, align 4
*** divergent data dependency:
  %28 = load i32, ptr %27, align 4
*** divergent data dependency:
  %30 = load i32, ptr %29, align 4
*** divergent data dependency:
  %24 = getelementptr ptr, ptr %0, i32 5
*** divergent data dependency:
  %21 = getelementptr ptr, ptr %0, i32 4
*** divergent data dependency:
  %9 = getelementptr ptr, ptr %0, i32 3
*** divergent data dependency:
  %6 = getelementptr ptr, ptr %0, i32 2
*** divergent data dependency:
  %18 = getelementptr ptr, ptr %0, i32 1
*** divergent data dependency:
  %16 = load ptr, ptr %0, align 4
*** divergent data dependency:
  %17 = load ptr, ptr %16, align 4
*** divergent data dependency:
  %19 = load ptr, ptr %18, align 4
*** divergent data dependency:
  %20 = load ptr, ptr %19, align 4
*** divergent data dependency:
  %7 = load ptr, ptr %6, align 4
*** divergent data dependency:
  %8 = load ptr, ptr %7, align 4
*** divergent data dependency:
  %10 = load ptr, ptr %9, align 4
*** divergent data dependency:
  %11 = load i32, ptr %10, align 4
*** divergent data dependency:
  %cmp61.not.i.i = icmp eq i32 %11, 0
*** divergent data dependency:
  br i1 %cmp61.not.i.i, label %_pocl_kernel_matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
*** divergent data dependency:
  %22 = load ptr, ptr %21, align 4
*** divergent data dependency:
  %23 = load ptr, ptr %22, align 4
*** divergent data dependency:
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %23, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %48 = load float, ptr %lsr.iv3, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
*** divergent data dependency:
  %25 = load ptr, ptr %24, align 4
*** divergent data dependency:
  %26 = load ptr, ptr %25, align 4
*** divergent data dependency:
  %.lcssa = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ]
*** divergent data dependency:
  %46 = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ]

After divergence analysis on _pocl_kernel_matmul_workgroup:
DIVERGENT: ptr %0
DIVERGENT: ptr %1
DIVERGENT: i32 %2
DIVERGENT: i32 %3
DIVERGENT: i32 %4

           :
DIVERGENT:       %6 = getelementptr ptr, ptr %0, i32 2
DIVERGENT:       %7 = load ptr, ptr %6, align 4
DIVERGENT:       %8 = load ptr, ptr %7, align 4
DIVERGENT:       %9 = getelementptr ptr, ptr %0, i32 3
DIVERGENT:       %10 = load ptr, ptr %9, align 4
DIVERGENT:       %11 = load i32, ptr %10, align 4
DIVERGENT:       %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
DIVERGENT:       %13 = load i32, ptr %12, align 4
DIVERGENT:       %.fr = freeze i32 %13
DIVERGENT:       %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
DIVERGENT:       %15 = load i32, ptr %14, align 4
DIVERGENT:       %mul.i.i.i = mul i32 %.fr, %2
DIVERGENT:       %add.i.i.i = add i32 %mul.i.i.i, %15
DIVERGENT:       %cmp61.not.i.i = icmp eq i32 %11, 0
DIVERGENT:       br i1 %cmp61.not.i.i, label %_pocl_kernel_matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i

           for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i:
DIVERGENT:       %16 = load ptr, ptr %0, align 4
DIVERGENT:       %17 = load ptr, ptr %16, align 4
DIVERGENT:       %18 = getelementptr ptr, ptr %0, i32 1
DIVERGENT:       %19 = load ptr, ptr %18, align 4
DIVERGENT:       %20 = load ptr, ptr %19, align 4
DIVERGENT:       %21 = getelementptr ptr, ptr %0, i32 4
DIVERGENT:       %22 = load ptr, ptr %21, align 4
DIVERGENT:       %23 = load ptr, ptr %22, align 4
DIVERGENT:       %24 = getelementptr ptr, ptr %0, i32 5
DIVERGENT:       %25 = load ptr, ptr %24, align 4
DIVERGENT:       %26 = load ptr, ptr %25, align 4
DIVERGENT:       %27 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
DIVERGENT:       %28 = load i32, ptr %27, align 4
DIVERGENT:       %29 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
DIVERGENT:       %30 = load i32, ptr %29, align 4
DIVERGENT:       %31 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %31) #2
DIVERGENT:       %mul3.i.i.i = mul i32 %30, %3
DIVERGENT:       %add6.i.i.i = add i32 %mul3.i.i.i, %28
DIVERGENT:       %mul.i.i = mul i32 %add6.i.i.i, %11
DIVERGENT:       %cmp1758.i.i = icmp sgt i32 %.fr, 0
DIVERGENT:       %32 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %32) #2
DIVERGENT:       br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader

           for.body.prebarrier.i.i.preheader:
DIVERGENT:       %33 = shl i32 %add.i.i.i, 2
DIVERGENT:       %uglygep5 = getelementptr i8, ptr %20, i32 %33
DIVERGENT:       %34 = mul i32 %.fr, %11
DIVERGENT:       %35 = shl i32 %34, 2
DIVERGENT:       %36 = mul i32 %11, %add6.i.i.i
DIVERGENT:       %37 = shl i32 %36, 2
DIVERGENT:       %uglygep8 = getelementptr i8, ptr %17, i32 %37
DIVERGENT:       %38 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.i

           for.body.prebarrier.i.i.us.preheader:
DIVERGENT:       %39 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.i.us

           for.body.prebarrier.i.i.us:
DIVERGENT:       %.lcssa5.us = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ], [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ]
DIVERGENT:       %40 = phi i32 [ %53, %for.cond.cleanup18.loopexit.i.i.us ], [ 0, %for.body.prebarrier.i.i.us.preheader ]
DIVERGENT:       %add5.i.i.us = add i32 %40, %mul.i.i
DIVERGENT:       %arrayidx.i.i.us = getelementptr inbounds float, ptr %17, i32 %add5.i.i.us
DIVERGENT:       %41 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !28
DIVERGENT:       store float %41, ptr %23, align 4, !tbaa !28
DIVERGENT:       %mul10.i.i.us = mul i32 %40, %11
DIVERGENT:       %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
DIVERGENT:       %arrayidx12.i.i.us = getelementptr inbounds float, ptr %20, i32 %add11.i.i.us
DIVERGENT:       %42 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !28
DIVERGENT:       store float %42, ptr %26, align 4, !tbaa !28
DIVERGENT:       %43 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %43) #2
DIVERGENT:       %44 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %44) #2
DIVERGENT:       %45 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %45) #2
                 br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us

           for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us:
DIVERGENT:       %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %23, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %26, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %46 = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %47 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %47) #2
DIVERGENT:       %48 = load float, ptr %lsr.iv3, align 4, !tbaa !28
DIVERGENT:       %49 = load float, ptr %lsr.iv2, align 4, !tbaa !28
DIVERGENT:       %50 = tail call float @llvm.fmuladd.f32(float %48, float %49, float %46)
DIVERGENT:       %51 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %51) #2
DIVERGENT:       %lsr.iv.next = add i32 %lsr.iv, -1
DIVERGENT:       %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %39
DIVERGENT:       %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
DIVERGENT:       %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
DIVERGENT:       br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !32

           for.cond.cleanup18.loopexit.i.i.us:
DIVERGENT:       %.lcssa = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ]
DIVERGENT:       %52 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %52) #2
DIVERGENT:       %53 = add nsw i32 %40, %.fr
DIVERGENT:       %54 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %54) #2
DIVERGENT:       %55 = icmp ult i32 %53, %11
DIVERGENT:       br i1 %55, label %for.body.prebarrier.i.i.us, label %for.cond.cleanup.loopexit.btr.i.i, !llvm.loop !34

           for.cond.cleanup.loopexit.i.i:
DIVERGENT:       %56 = add i32 %mul.i.i, %add.i.i.i
                 br label %_pocl_kernel_matmul.exit

           for.body.prebarrier.i.i:
DIVERGENT:       %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
DIVERGENT:       %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
DIVERGENT:       %57 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
DIVERGENT:       %58 = load float, ptr %lsr.iv9, align 4, !tbaa !28
DIVERGENT:       store float %58, ptr %23, align 4, !tbaa !28
DIVERGENT:       %59 = load float, ptr %lsr.iv6, align 4, !tbaa !28
DIVERGENT:       store float %59, ptr %26, align 4, !tbaa !28
DIVERGENT:       %60 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %60) #2
DIVERGENT:       %61 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %61) #2
DIVERGENT:       %add28.i.i = add i32 %57, %.fr
DIVERGENT:       %62 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %62) #2
DIVERGENT:       %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %35
DIVERGENT:       %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %38
DIVERGENT:       %cmp.i.i = icmp ult i32 %add28.i.i, %11
DIVERGENT:       br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !34

           for.cond.cleanup.loopexit.btr.i.i:
DIVERGENT:       %.lcssa.lcssa = phi float [ %.lcssa, %for.cond.cleanup18.loopexit.i.i.us ]
DIVERGENT:       %63 = add i32 %mul.i.i, %add.i.i.i
                 br label %_pocl_kernel_matmul.exit

           _pocl_kernel_matmul.exit:
DIVERGENT:       %.sink10 = phi i32 [ %56, %for.cond.cleanup.loopexit.i.i ], [ %63, %for.cond.cleanup.loopexit.btr.i.i ], [ %add.i.i.i, %5 ]
DIVERGENT:       %.sink = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %.lcssa.lcssa, %for.cond.cleanup.loopexit.btr.i.i ], [ 0.000000e+00, %5 ]
DIVERGENT:       %64 = getelementptr inbounds float, ptr %8, i32 %.sink10
DIVERGENT:       store float %.sink, ptr %64, align 4, !tbaa !28
                 ret void

*** structurize: skip divergent complete region for.body.prebarrier.i.i => for.cond.cleanup.loopexit.i.i
*** structurize: skip divergent complete region for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us => for.cond.cleanup18.loopexit.i.i.us
*** structurize: divergent non-regional block: for.body.prebarrier.i.i.us => for.cond.cleanup.loopexit.btr.i.i
Visiting: for.body.prebarrier.i.i.us
Visiting: SubRegion with entry: for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us
Visiting: for.cond.cleanup18.loopexit.i.i.us
*** structurize: skip divergent complete region for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i => _pocl_kernel_matmul.exit
*** structurize: skip divergent complete region %5 => _pocl_kernel_matmul.exit
*** DivergenceTracker::initialize(): _pocl_kernel_matmul_workgroup
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent return variable: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent function argument: 
*** divergent data dependency:
  %mul3.i.i.i = mul i32 %30, %3
*** divergent data dependency:
  %add6.i.i.i = add i32 %mul3.i.i.i, %28
*** divergent data dependency:
  %36 = mul i32 %11, %add6.i.i.i
*** divergent data dependency:
  %mul.i.i = mul i32 %add6.i.i.i, %11
*** divergent data dependency:
  %63 = add i32 %mul.i.i, %add.i.i.i
*** divergent data dependency:
  %56 = add i32 %mul.i.i, %add.i.i.i
*** divergent data dependency:
  %add5.i.i.us = add i32 %40, %mul.i.i
*** divergent data dependency:
  %arrayidx.i.i.us = getelementptr inbounds float, ptr %17, i32 %add5.i.i.us
*** divergent data dependency:
  %41 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !28
*** divergent data dependency:
  store float %41, ptr %23, align 4, !tbaa !28
*** divergent data dependency:
  %.sink10 = phi i32 [ %56, %for.cond.cleanup.loopexit.i.i ], [ %63, %for.cond.cleanup.loopexit.btr.i.i ], [ %add.i.i.i, %5 ]
*** divergent data dependency:
  %64 = getelementptr inbounds float, ptr %8, i32 %.sink10
*** divergent data dependency:
  store float %.sink, ptr %64, align 4, !tbaa !28
*** divergent data dependency:
  %37 = shl i32 %36, 2
*** divergent data dependency:
  %uglygep8 = getelementptr i8, ptr %17, i32 %37
*** divergent data dependency:
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
*** divergent data dependency:
  %58 = load float, ptr %lsr.iv9, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %38
*** divergent data dependency:
  store float %58, ptr %23, align 4, !tbaa !28
*** divergent data dependency:
  %mul.i.i.i = mul i32 %.fr, %2
*** divergent data dependency:
  %add.i.i.i = add i32 %mul.i.i.i, %15
*** divergent data dependency:
  %33 = shl i32 %add.i.i.i, 2
*** divergent data dependency:
  %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
*** divergent data dependency:
  %arrayidx12.i.i.us = getelementptr inbounds float, ptr %20, i32 %add11.i.i.us
*** divergent data dependency:
  %42 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !28
*** divergent data dependency:
  store float %42, ptr %26, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep5 = getelementptr i8, ptr %20, i32 %33
*** divergent data dependency:
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
*** divergent data dependency:
  %59 = load float, ptr %lsr.iv6, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %35
*** divergent data dependency:
  store float %59, ptr %26, align 4, !tbaa !28
*** divergent data dependency:
  %29 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
*** divergent data dependency:
  %27 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
*** divergent data dependency:
  %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
*** divergent data dependency:
  %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
*** divergent data dependency:
  %13 = load i32, ptr %12, align 4
*** divergent data dependency:
  %.fr = freeze i32 %13
*** divergent data dependency:
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %38 = shl i32 %.fr, 2
*** divergent data dependency:
  %34 = mul i32 %.fr, %11
*** divergent data dependency:
  %39 = shl i32 %.fr, 2
*** divergent data dependency:
  %53 = add nsw i32 %40, %.fr
*** divergent data dependency:
  %add28.i.i = add i32 %57, %.fr
*** divergent data dependency:
  %cmp1758.i.i = icmp sgt i32 %.fr, 0
*** divergent data dependency:
  br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader
*** divergent sync dependency
  %.sink = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %50, %for.cond.cleanup.loopexit.btr.i.i ], [ 0.000000e+00, %5 ]
*** divergent data dependency:
  %cmp.i.i = icmp ult i32 %add28.i.i, %11
*** divergent data dependency:
  %57 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
*** divergent data dependency:
  br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !34
*** divergent data dependency:
  %40 = phi i32 [ 0, %for.body.prebarrier.i.i.us.preheader ], [ %53, %for.cond.cleanup18.loopexit.i.i.us ]
*** divergent data dependency:
  %55 = icmp uge i32 %53, %11
*** divergent data dependency:
  br i1 %55, label %for.cond.cleanup.loopexit.btr.i.i, label %for.body.prebarrier.i.i.us
*** divergent data dependency:
  %mul10.i.i.us = mul i32 %40, %11
*** divergent data dependency:
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %39
*** divergent data dependency:
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %26, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %49 = load float, ptr %lsr.iv2, align 4, !tbaa !28
*** divergent data dependency:
  %35 = shl i32 %34, 2
*** divergent data dependency:
  %lsr.iv.next = add i32 %lsr.iv, -1
*** divergent data dependency:
  %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
*** divergent data dependency:
  br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !32
*** divergent data dependency:
  %15 = load i32, ptr %14, align 4
*** divergent data dependency:
  %28 = load i32, ptr %27, align 4
*** divergent data dependency:
  %30 = load i32, ptr %29, align 4
*** divergent data dependency:
  %24 = getelementptr ptr, ptr %0, i32 5
*** divergent data dependency:
  %21 = getelementptr ptr, ptr %0, i32 4
*** divergent data dependency:
  %9 = getelementptr ptr, ptr %0, i32 3
*** divergent data dependency:
  %6 = getelementptr ptr, ptr %0, i32 2
*** divergent data dependency:
  %18 = getelementptr ptr, ptr %0, i32 1
*** divergent data dependency:
  %16 = load ptr, ptr %0, align 4
*** divergent data dependency:
  %17 = load ptr, ptr %16, align 4
*** divergent data dependency:
  %19 = load ptr, ptr %18, align 4
*** divergent data dependency:
  %20 = load ptr, ptr %19, align 4
*** divergent data dependency:
  %7 = load ptr, ptr %6, align 4
*** divergent data dependency:
  %8 = load ptr, ptr %7, align 4
*** divergent data dependency:
  %10 = load ptr, ptr %9, align 4
*** divergent data dependency:
  %11 = load i32, ptr %10, align 4
*** divergent data dependency:
  %cmp61.not.i.i = icmp eq i32 %11, 0
*** divergent data dependency:
  br i1 %cmp61.not.i.i, label %_pocl_kernel_matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
*** divergent data dependency:
  %22 = load ptr, ptr %21, align 4
*** divergent data dependency:
  %23 = load ptr, ptr %22, align 4
*** divergent data dependency:
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %23, %for.body.prebarrier.i.i.us ]
*** divergent data dependency:
  %48 = load float, ptr %lsr.iv3, align 4, !tbaa !28
*** divergent data dependency:
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
*** divergent data dependency:
  %25 = load ptr, ptr %24, align 4
*** divergent data dependency:
  %26 = load ptr, ptr %25, align 4
*** divergent data dependency:
  %.lcssa5.us = phi float [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ], [ %50, %for.cond.cleanup18.loopexit.i.i.us ]
*** divergent data dependency:
  %46 = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]

After divergence analysis on _pocl_kernel_matmul_workgroup:
DIVERGENT: ptr %0
DIVERGENT: ptr %1
DIVERGENT: i32 %2
DIVERGENT: i32 %3
DIVERGENT: i32 %4

           :
DIVERGENT:       %6 = getelementptr ptr, ptr %0, i32 2
DIVERGENT:       %7 = load ptr, ptr %6, align 4
DIVERGENT:       %8 = load ptr, ptr %7, align 4
DIVERGENT:       %9 = getelementptr ptr, ptr %0, i32 3
DIVERGENT:       %10 = load ptr, ptr %9, align 4
DIVERGENT:       %11 = load i32, ptr %10, align 4
DIVERGENT:       %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
DIVERGENT:       %13 = load i32, ptr %12, align 4
DIVERGENT:       %.fr = freeze i32 %13
DIVERGENT:       %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
DIVERGENT:       %15 = load i32, ptr %14, align 4
DIVERGENT:       %mul.i.i.i = mul i32 %.fr, %2
DIVERGENT:       %add.i.i.i = add i32 %mul.i.i.i, %15
DIVERGENT:       %cmp61.not.i.i = icmp eq i32 %11, 0
DIVERGENT:       br i1 %cmp61.not.i.i, label %_pocl_kernel_matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i

           for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i:
DIVERGENT:       %16 = load ptr, ptr %0, align 4
DIVERGENT:       %17 = load ptr, ptr %16, align 4
DIVERGENT:       %18 = getelementptr ptr, ptr %0, i32 1
DIVERGENT:       %19 = load ptr, ptr %18, align 4
DIVERGENT:       %20 = load ptr, ptr %19, align 4
DIVERGENT:       %21 = getelementptr ptr, ptr %0, i32 4
DIVERGENT:       %22 = load ptr, ptr %21, align 4
DIVERGENT:       %23 = load ptr, ptr %22, align 4
DIVERGENT:       %24 = getelementptr ptr, ptr %0, i32 5
DIVERGENT:       %25 = load ptr, ptr %24, align 4
DIVERGENT:       %26 = load ptr, ptr %25, align 4
DIVERGENT:       %27 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
DIVERGENT:       %28 = load i32, ptr %27, align 4
DIVERGENT:       %29 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
DIVERGENT:       %30 = load i32, ptr %29, align 4
DIVERGENT:       %31 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %31) #2
DIVERGENT:       %mul3.i.i.i = mul i32 %30, %3
DIVERGENT:       %add6.i.i.i = add i32 %mul3.i.i.i, %28
DIVERGENT:       %mul.i.i = mul i32 %add6.i.i.i, %11
DIVERGENT:       %cmp1758.i.i = icmp sgt i32 %.fr, 0
DIVERGENT:       %32 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %32) #2
DIVERGENT:       br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader

           for.body.prebarrier.i.i.preheader:
DIVERGENT:       %33 = shl i32 %add.i.i.i, 2
DIVERGENT:       %uglygep5 = getelementptr i8, ptr %20, i32 %33
DIVERGENT:       %34 = mul i32 %.fr, %11
DIVERGENT:       %35 = shl i32 %34, 2
DIVERGENT:       %36 = mul i32 %11, %add6.i.i.i
DIVERGENT:       %37 = shl i32 %36, 2
DIVERGENT:       %uglygep8 = getelementptr i8, ptr %17, i32 %37
DIVERGENT:       %38 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.i

           for.body.prebarrier.i.i.us.preheader:
DIVERGENT:       %39 = shl i32 %.fr, 2
                 br label %for.body.prebarrier.i.i.us

           for.body.prebarrier.i.i.us:
DIVERGENT:       %.lcssa5.us = phi float [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ], [ %50, %for.cond.cleanup18.loopexit.i.i.us ]
DIVERGENT:       %40 = phi i32 [ 0, %for.body.prebarrier.i.i.us.preheader ], [ %53, %for.cond.cleanup18.loopexit.i.i.us ]
DIVERGENT:       %add5.i.i.us = add i32 %40, %mul.i.i
DIVERGENT:       %arrayidx.i.i.us = getelementptr inbounds float, ptr %17, i32 %add5.i.i.us
DIVERGENT:       %41 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !28
DIVERGENT:       store float %41, ptr %23, align 4, !tbaa !28
DIVERGENT:       %mul10.i.i.us = mul i32 %40, %11
DIVERGENT:       %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
DIVERGENT:       %arrayidx12.i.i.us = getelementptr inbounds float, ptr %20, i32 %add11.i.i.us
DIVERGENT:       %42 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !28
DIVERGENT:       store float %42, ptr %26, align 4, !tbaa !28
DIVERGENT:       %43 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %43) #2
DIVERGENT:       %44 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %44) #2
DIVERGENT:       %45 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %45) #2
                 br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us

           for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us:
DIVERGENT:       %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %23, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %26, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %46 = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]
DIVERGENT:       %47 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %47) #2
DIVERGENT:       %48 = load float, ptr %lsr.iv3, align 4, !tbaa !28
DIVERGENT:       %49 = load float, ptr %lsr.iv2, align 4, !tbaa !28
DIVERGENT:       %50 = tail call float @llvm.fmuladd.f32(float %48, float %49, float %46)
DIVERGENT:       %51 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %51) #2
DIVERGENT:       %lsr.iv.next = add i32 %lsr.iv, -1
DIVERGENT:       %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %39
DIVERGENT:       %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
DIVERGENT:       %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
DIVERGENT:       br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !32

           for.cond.cleanup18.loopexit.i.i.us:
DIVERGENT:       %52 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %52) #2
DIVERGENT:       %53 = add nsw i32 %40, %.fr
DIVERGENT:       %54 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %54) #2
DIVERGENT:       %55 = icmp uge i32 %53, %11
DIVERGENT:       br i1 %55, label %for.cond.cleanup.loopexit.btr.i.i, label %for.body.prebarrier.i.i.us

           for.cond.cleanup.loopexit.i.i:
DIVERGENT:       %56 = add i32 %mul.i.i, %add.i.i.i
                 br label %_pocl_kernel_matmul.exit

           for.body.prebarrier.i.i:
DIVERGENT:       %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
DIVERGENT:       %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
DIVERGENT:       %57 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
DIVERGENT:       %58 = load float, ptr %lsr.iv9, align 4, !tbaa !28
DIVERGENT:       store float %58, ptr %23, align 4, !tbaa !28
DIVERGENT:       %59 = load float, ptr %lsr.iv6, align 4, !tbaa !28
DIVERGENT:       store float %59, ptr %26, align 4, !tbaa !28
DIVERGENT:       %60 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %60) #2
DIVERGENT:       %61 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %61) #2
DIVERGENT:       %add28.i.i = add i32 %57, %.fr
DIVERGENT:       %62 = tail call i32 (...) @vx_num_warps() #2
DIVERGENT:       tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %62) #2
DIVERGENT:       %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %35
DIVERGENT:       %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %38
DIVERGENT:       %cmp.i.i = icmp ult i32 %add28.i.i, %11
DIVERGENT:       br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !34

           for.cond.cleanup.loopexit.btr.i.i:
DIVERGENT:       %63 = add i32 %mul.i.i, %add.i.i.i
                 br label %_pocl_kernel_matmul.exit

           _pocl_kernel_matmul.exit:
DIVERGENT:       %.sink10 = phi i32 [ %56, %for.cond.cleanup.loopexit.i.i ], [ %63, %for.cond.cleanup.loopexit.btr.i.i ], [ %add.i.i.i, %5 ]
DIVERGENT:       %.sink = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %50, %for.cond.cleanup.loopexit.btr.i.i ], [ 0.000000e+00, %5 ]
DIVERGENT:       %64 = getelementptr inbounds float, ptr %8, i32 %.sink10
DIVERGENT:       store float %.sink, ptr %64, align 4, !tbaa !28
                 ret void

*** Vortex Divergent Branch Handling ***
*** Region info:
[0] %5 => <Function Return>
  [1] %5 => _pocl_kernel_matmul.exit
    [2] for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i => _pocl_kernel_matmul.exit
      [3] for.body.prebarrier.i.i.us => for.cond.cleanup.loopexit.btr.i.i
        [4] for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us => for.cond.cleanup18.loopexit.i.i.us
      [3] for.body.prebarrier.i.i => for.cond.cleanup.loopexit.i.i

*** divergent branch: BB.5, IPDOM=BB._pocl_kernel_matmul.exit
*** divergent branch: BB.for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i, IPDOM=BB._pocl_kernel_matmul.exit
*** skip non-conditional branch: BB.for.body.prebarrier.i.i.us.preheader
*** skip non-conditional branch: BB.for.body.prebarrier.i.i.us
*** divergent loop: BB.for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us
*** divergent loop: BB.for.body.prebarrier.i.i.us
*** skip non-conditional branch: BB.for.cond.cleanup.loopexit.btr.i.i
*** skip non-conditional branch: BB.for.body.prebarrier.i.i.preheader
*** divergent loop: BB.for.body.prebarrier.i.i
*** skip non-conditional branch: BB.for.cond.cleanup.loopexit.i.i
*** before changes!
; Function Attrs: nounwind
define void @_pocl_kernel_matmul_workgroup(ptr nocapture readonly %0, ptr nocapture readonly %1, i32 %2, i32 %3, i32 %4) local_unnamed_addr #2 {
  %6 = getelementptr ptr, ptr %0, i32 2
  %7 = load ptr, ptr %6, align 4
  %8 = load ptr, ptr %7, align 4
  %9 = getelementptr ptr, ptr %0, i32 3
  %10 = load ptr, ptr %9, align 4
  %11 = load i32, ptr %10, align 4
  %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
  %13 = load i32, ptr %12, align 4
  %.fr = freeze i32 %13
  %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
  %15 = load i32, ptr %14, align 4
  %mul.i.i.i = mul i32 %.fr, %2
  %add.i.i.i = add i32 %mul.i.i.i, %15
  %cmp61.not.i.i = icmp eq i32 %11, 0
  br i1 %cmp61.not.i.i, label %_pocl_kernel_matmul.exit, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i

for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i: ; preds = %5
  %16 = load ptr, ptr %0, align 4
  %17 = load ptr, ptr %16, align 4
  %18 = getelementptr ptr, ptr %0, i32 1
  %19 = load ptr, ptr %18, align 4
  %20 = load ptr, ptr %19, align 4
  %21 = getelementptr ptr, ptr %0, i32 4
  %22 = load ptr, ptr %21, align 4
  %23 = load ptr, ptr %22, align 4
  %24 = getelementptr ptr, ptr %0, i32 5
  %25 = load ptr, ptr %24, align 4
  %26 = load ptr, ptr %25, align 4
  %27 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
  %28 = load i32, ptr %27, align 4
  %29 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
  %30 = load i32, ptr %29, align 4
  %31 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %31) #2
  %mul3.i.i.i = mul i32 %30, %3
  %add6.i.i.i = add i32 %mul3.i.i.i, %28
  %mul.i.i = mul i32 %add6.i.i.i, %11
  %cmp1758.i.i = icmp sgt i32 %.fr, 0
  %32 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %32) #2
  br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader

for.body.prebarrier.i.i.preheader:                ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
  %33 = shl i32 %add.i.i.i, 2
  %uglygep5 = getelementptr i8, ptr %20, i32 %33
  %34 = mul i32 %.fr, %11
  %35 = shl i32 %34, 2
  %36 = mul i32 %11, %add6.i.i.i
  %37 = shl i32 %36, 2
  %uglygep8 = getelementptr i8, ptr %17, i32 %37
  %38 = shl i32 %.fr, 2
  br label %for.body.prebarrier.i.i

for.body.prebarrier.i.i.us.preheader:             ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
  %39 = shl i32 %.fr, 2
  br label %for.body.prebarrier.i.i.us

for.body.prebarrier.i.i.us:                       ; preds = %for.cond.cleanup18.loopexit.i.i.us, %for.body.prebarrier.i.i.us.preheader
  %.lcssa5.us = phi float [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ], [ %50, %for.cond.cleanup18.loopexit.i.i.us ]
  %40 = phi i32 [ 0, %for.body.prebarrier.i.i.us.preheader ], [ %53, %for.cond.cleanup18.loopexit.i.i.us ]
  %add5.i.i.us = add i32 %40, %mul.i.i
  %arrayidx.i.i.us = getelementptr inbounds float, ptr %17, i32 %add5.i.i.us
  %41 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !34
  store float %41, ptr %23, align 4, !tbaa !34
  %mul10.i.i.us = mul i32 %40, %11
  %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
  %arrayidx12.i.i.us = getelementptr inbounds float, ptr %20, i32 %add11.i.i.us
  %42 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !34
  store float %42, ptr %26, align 4, !tbaa !34
  %43 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %43) #2
  %44 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %44) #2
  %45 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %45) #2
  br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us

for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us: ; preds = %for.body.prebarrier.i.i.us, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %23, %for.body.prebarrier.i.i.us ]
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %26, %for.body.prebarrier.i.i.us ]
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
  %46 = phi float [ %50, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]
  %47 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %47) #2
  %48 = load float, ptr %lsr.iv3, align 4, !tbaa !34
  %49 = load float, ptr %lsr.iv2, align 4, !tbaa !34
  %50 = tail call float @llvm.fmuladd.f32(float %48, float %49, float %46)
  %51 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %51) #2
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %39
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
  %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
  br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !38

for.cond.cleanup18.loopexit.i.i.us:               ; preds = %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us
  %52 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %52) #2
  %53 = add nsw i32 %40, %.fr
  %54 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %54) #2
  %55 = icmp uge i32 %53, %11
  br i1 %55, label %for.cond.cleanup.loopexit.btr.i.i, label %for.body.prebarrier.i.i.us

for.cond.cleanup.loopexit.i.i:                    ; preds = %for.body.prebarrier.i.i
  %56 = add i32 %mul.i.i, %add.i.i.i
  br label %_pocl_kernel_matmul.exit

for.body.prebarrier.i.i:                          ; preds = %for.body.prebarrier.i.i.preheader, %for.body.prebarrier.i.i
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
  %57 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
  %58 = load float, ptr %lsr.iv9, align 4, !tbaa !34
  store float %58, ptr %23, align 4, !tbaa !34
  %59 = load float, ptr %lsr.iv6, align 4, !tbaa !34
  store float %59, ptr %26, align 4, !tbaa !34
  %60 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %60) #2
  %61 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %61) #2
  %add28.i.i = add i32 %57, %.fr
  %62 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %62) #2
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %35
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %38
  %cmp.i.i = icmp ult i32 %add28.i.i, %11
  br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !40

for.cond.cleanup.loopexit.btr.i.i:                ; preds = %for.cond.cleanup18.loopexit.i.i.us
  %63 = add i32 %mul.i.i, %add.i.i.i
  br label %_pocl_kernel_matmul.exit

_pocl_kernel_matmul.exit:                         ; preds = %for.cond.cleanup.loopexit.btr.i.i, %for.cond.cleanup.loopexit.i.i, %5
  %.sink10 = phi i32 [ %56, %for.cond.cleanup.loopexit.i.i ], [ %63, %for.cond.cleanup.loopexit.btr.i.i ], [ %add.i.i.i, %5 ]
  %.sink = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %50, %for.cond.cleanup.loopexit.btr.i.i ], [ 0.000000e+00, %5 ]
  %64 = getelementptr inbounds float, ptr %8, i32 %.sink10
  store float %.sink, ptr %64, align 4, !tbaa !34
  ret void
}

*** process loop: BB.for.body.prebarrier.i.i
*** backup thread mask 'V.tmask' before loop preheader branch: BB.for.body.prebarrier.i.i.preheader
*** insert thread predicate 'V.V.cmp.i.i.i32' before exiting block: BB.for.body.prebarrier.i.i
*** after predicate change!
0x55f2b524d978
*** process loop: BB.for.body.prebarrier.i.i.us
*** backup thread mask 'V.tmask11' before loop preheader branch: BB.for.body.prebarrier.i.i.us.preheader
*** insert thread predicate 'V.V.V.55.not.i32' before exiting block: BB.for.cond.cleanup18.loopexit.i.i.us
*** after predicate change!
0x55f2b524d978
*** process loop: BB.for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us
*** backup thread mask 'V.tmask12' before loop preheader branch: BB.for.body.prebarrier.i.i.us
*** insert thread predicate 'V.V.V.exitcond.not.i.i.us.not.i32' before exiting block: BB.for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us
*** after predicate change!
0x55f2b524d978
*** process branch BB.for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i, region=for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i => _pocl_kernel_matmul.exit
*** insert split 'V.V.cmp1758.i.i.i32' before BB.for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i's branch.
*** insert join stub 'join_stub' before BB._pocl_kernel_matmul.exit
****** replace BB.for.cond.cleanup.loopexit.i.i.succ[0]: BB._pocl_kernel_matmul.exit with BB.join_stub
****** replace BB.for.cond.cleanup.loopexit.btr.i.i.succ[0]: BB._pocl_kernel_matmul.exit with BB.join_stub
*** process branch BB.5, region=%5 => _pocl_kernel_matmul.exit
*** insert split 'V.V.cmp61.not.i.i.i32' before BB.5's branch.
*** insert join stub 'join_stub15' before BB._pocl_kernel_matmul.exit
****** replace BB.join_stub.succ[0]: BB._pocl_kernel_matmul.exit with BB.join_stub15
****** replace BB.5.succ[0]: BB._pocl_kernel_matmul.exit with BB.join_stub15
*** after changes!
; Function Attrs: nounwind
define void @_pocl_kernel_matmul_workgroup(ptr nocapture readonly %0, ptr nocapture readonly %1, i32 %2, i32 %3, i32 %4) local_unnamed_addr #2 {
  %6 = getelementptr ptr, ptr %0, i32 2
  %7 = load ptr, ptr %6, align 4
  %8 = load ptr, ptr %7, align 4
  %9 = getelementptr ptr, ptr %0, i32 3
  %10 = load ptr, ptr %9, align 4
  %11 = load i32, ptr %10, align 4
  %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
  %13 = load i32, ptr %12, align 4
  %.fr = freeze i32 %13
  %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
  %15 = load i32, ptr %14, align 4
  %mul.i.i.i = mul i32 %.fr, %2
  %add.i.i.i = add i32 %mul.i.i.i, %15
  %cmp61.not.i.i = icmp eq i32 %11, 0
  %V.cmp61.not.i.i.i32 = zext i1 %cmp61.not.i.i to i32
  %16 = call i32 @llvm.riscv.vx.split.i32.i32(i32 %V.cmp61.not.i.i.i32)
  br i1 %cmp61.not.i.i, label %join_stub15, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i

for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i: ; preds = %5
  %17 = load ptr, ptr %0, align 4
  %18 = load ptr, ptr %17, align 4
  %19 = getelementptr ptr, ptr %0, i32 1
  %20 = load ptr, ptr %19, align 4
  %21 = load ptr, ptr %20, align 4
  %22 = getelementptr ptr, ptr %0, i32 4
  %23 = load ptr, ptr %22, align 4
  %24 = load ptr, ptr %23, align 4
  %25 = getelementptr ptr, ptr %0, i32 5
  %26 = load ptr, ptr %25, align 4
  %27 = load ptr, ptr %26, align 4
  %28 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
  %29 = load i32, ptr %28, align 4
  %30 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
  %31 = load i32, ptr %30, align 4
  %32 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 5, i32 %32) #2
  %mul3.i.i.i = mul i32 %31, %3
  %add6.i.i.i = add i32 %mul3.i.i.i, %29
  %mul.i.i = mul i32 %add6.i.i.i, %11
  %cmp1758.i.i = icmp sgt i32 %.fr, 0
  %33 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 10, i32 %33) #2
  %V.cmp1758.i.i.i32 = zext i1 %cmp1758.i.i to i32
  %34 = call i32 @llvm.riscv.vx.split.i32.i32(i32 %V.cmp1758.i.i.i32)
  br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader

for.body.prebarrier.i.i.preheader:                ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
  %35 = shl i32 %add.i.i.i, 2
  %uglygep5 = getelementptr i8, ptr %21, i32 %35
  %36 = mul i32 %.fr, %11
  %37 = shl i32 %36, 2
  %38 = mul i32 %11, %add6.i.i.i
  %39 = shl i32 %38, 2
  %uglygep8 = getelementptr i8, ptr %18, i32 %39
  %40 = shl i32 %.fr, 2
  %tmask = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body.prebarrier.i.i

for.body.prebarrier.i.i.us.preheader:             ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
  %41 = shl i32 %.fr, 2
  %tmask11 = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body.prebarrier.i.i.us

for.body.prebarrier.i.i.us:                       ; preds = %for.cond.cleanup18.loopexit.i.i.us, %for.body.prebarrier.i.i.us.preheader
  %.lcssa5.us = phi float [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ], [ %52, %for.cond.cleanup18.loopexit.i.i.us ]
  %42 = phi i32 [ 0, %for.body.prebarrier.i.i.us.preheader ], [ %55, %for.cond.cleanup18.loopexit.i.i.us ]
  %add5.i.i.us = add i32 %42, %mul.i.i
  %arrayidx.i.i.us = getelementptr inbounds float, ptr %18, i32 %add5.i.i.us
  %43 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !34
  store float %43, ptr %24, align 4, !tbaa !34
  %mul10.i.i.us = mul i32 %42, %11
  %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
  %arrayidx12.i.i.us = getelementptr inbounds float, ptr %21, i32 %add11.i.i.us
  %44 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !34
  store float %44, ptr %27, align 4, !tbaa !34
  %45 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %45) #2
  %46 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 1, i32 %46) #2
  %47 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 11, i32 %47) #2
  %tmask12 = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us

for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us: ; preds = %for.body.prebarrier.i.i.us, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %24, %for.body.prebarrier.i.i.us ]
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %27, %for.body.prebarrier.i.i.us ]
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
  %48 = phi float [ %52, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]
  %49 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 8, i32 %49) #2
  %50 = load float, ptr %lsr.iv3, align 4, !tbaa !34
  %51 = load float, ptr %lsr.iv2, align 4, !tbaa !34
  %52 = tail call float @llvm.fmuladd.f32(float %50, float %51, float %48)
  %53 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 4, i32 %53) #2
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %41
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
  %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
  %V.exitcond.not.i.i.us.not = xor i1 %exitcond.not.i.i.us, true
  %V.V.exitcond.not.i.i.us.not.i32 = zext i1 %V.exitcond.not.i.i.us.not to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.V.exitcond.not.i.i.us.not.i32, i32 %tmask12)
  br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !38

for.cond.cleanup18.loopexit.i.i.us:               ; preds = %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us
  %54 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 6, i32 %54) #2
  %55 = add nsw i32 %42, %.fr
  %56 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 7, i32 %56) #2
  %57 = icmp uge i32 %55, %11
  %V.55.not = xor i1 %57, true
  %V.V.55.not.i32 = zext i1 %V.55.not to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.V.55.not.i32, i32 %tmask11)
  br i1 %57, label %for.cond.cleanup.loopexit.btr.i.i, label %for.body.prebarrier.i.i.us

for.cond.cleanup.loopexit.i.i:                    ; preds = %for.body.prebarrier.i.i
  %58 = add i32 %mul.i.i, %add.i.i.i
  br label %join_stub

for.body.prebarrier.i.i:                          ; preds = %for.body.prebarrier.i.i.preheader, %for.body.prebarrier.i.i
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
  %59 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
  %60 = load float, ptr %lsr.iv9, align 4, !tbaa !34
  store float %60, ptr %24, align 4, !tbaa !34
  %61 = load float, ptr %lsr.iv6, align 4, !tbaa !34
  store float %61, ptr %27, align 4, !tbaa !34
  %62 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 2, i32 %62) #2
  %63 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 3, i32 %63) #2
  %add28.i.i = add i32 %59, %.fr
  %64 = tail call i32 (...) @vx_num_warps() #2
  tail call void (i32, i32, ...) @vx_barrier(i32 9, i32 %64) #2
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %37
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %40
  %cmp.i.i = icmp ult i32 %add28.i.i, %11
  %V.cmp.i.i.i32 = zext i1 %cmp.i.i to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.cmp.i.i.i32, i32 %tmask)
  br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !40

for.cond.cleanup.loopexit.btr.i.i:                ; preds = %for.cond.cleanup18.loopexit.i.i.us
  %65 = add i32 %mul.i.i, %add.i.i.i
  br label %join_stub

join_stub:                                        ; preds = %for.cond.cleanup.loopexit.btr.i.i, %for.cond.cleanup.loopexit.i.i
  %.sink14 = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %52, %for.cond.cleanup.loopexit.btr.i.i ]
  %.sink1013 = phi i32 [ %58, %for.cond.cleanup.loopexit.i.i ], [ %65, %for.cond.cleanup.loopexit.btr.i.i ]
  call void @llvm.riscv.vx.join.i32(i32 %34)
  br label %join_stub15

join_stub15:                                      ; preds = %5, %join_stub
  %.sink17 = phi float [ %.sink14, %join_stub ], [ 0.000000e+00, %5 ]
  %.sink1016 = phi i32 [ %.sink1013, %join_stub ], [ %add.i.i.i, %5 ]
  call void @llvm.riscv.vx.join.i32(i32 %16)
  br label %_pocl_kernel_matmul.exit

_pocl_kernel_matmul.exit:                         ; preds = %join_stub15
  %.sink10 = phi i32 [ %.sink1016, %join_stub15 ]
  %.sink = phi float [ %.sink17, %join_stub15 ]
  %66 = getelementptr inbounds float, ptr %8, i32 %.sink10
  store float %.sink, ptr %66, align 4, !tbaa !34
  ret void
}

VORTEX Intrinsic Func pass 
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace, preprocessed source, and associated run script.
Stack dump:
0.	Program arguments: /scratch/nicolas.a.castaneda/build/llvm-vortex/bin/clang -march=rv32imaf -mabi=ilp32f -v -O3 --sysroot=/home/eecs/nicolas.a.castaneda/vortex-toolchain-prebuilt/riscv-gnu-toolchain/riscv32-unknown-elf --gcc-toolchain=/home/eecs/nicolas.a.castaneda/vortex-toolchain-prebuilt/riscv-gnu-toolchain -Xclang -target-feature -Xclang +vortex -fno-rtti -fno-exceptions -nostartfiles -fdata-sections -ffunction-sections -I/home/eecs/nicolas.a.castaneda/vortex2/kernel/include -DNDEBUG -DLLVM_VOTEX /home/eecs/nicolas.a.castaneda/.cache/pocl/kcache/PH/OJHLLAIOAHLNICJFIGMMKLAIJOPDBOGOODMAO/matmul/0-0-0/parallel.bc -c -o /home/eecs/nicolas.a.castaneda/.cache/pocl/kcache/tempfile_ySArAn.so.o
1.	Code generation
2.	Running pass 'Function Pass Manager' on module '/home/eecs/nicolas.a.castaneda/.cache/pocl/kcache/PH/OJHLLAIOAHLNICJFIGMMKLAIJOPDBOGOODMAO/matmul/0-0-0/parallel.bc'.
3.	Running pass 'RISCV DAG->DAG Pattern Instruction Selection' on function '@_pocl_kernel_matmul'
 #0 0x00007faf97adc2b0 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/nicolas.a.castaneda/llvm/llvm/lib/Support/Unix/Signals.inc:567:22
 #1 0x00007faf97adc678 PrintStackTraceSignalHandler(void*) /scratch/nicolas.a.castaneda/llvm/llvm/lib/Support/Unix/Signals.inc:641:1
 #2 0x00007faf97ad9f6f llvm::sys::RunSignalHandlers() /scratch/nicolas.a.castaneda/llvm/llvm/lib/Support/Signals.cpp:104:20
 #3 0x00007faf97adbac4 llvm::sys::CleanupOnSignal(unsigned long) /scratch/nicolas.a.castaneda/llvm/llvm/lib/Support/Unix/Signals.inc:366:31
 #4 0x00007faf97942826 (anonymous namespace)::CrashRecoveryContextImpl::HandleCrash(int, unsigned long) /scratch/nicolas.a.castaneda/llvm/llvm/lib/Support/CrashRecoveryContext.cpp:73:5
 #5 0x00007faf97942d52 CrashRecoverySignalHandler(int) /scratch/nicolas.a.castaneda/llvm/llvm/lib/Support/CrashRecoveryContext.cpp:391:1
 #6 0x00007faf97487090 (/lib/x86_64-linux-gnu/libc.so.6+0x43090)
 #7 0x00007faf967adf64 llvm::EVT::operator!=(llvm::EVT) const /scratch/nicolas.a.castaneda/llvm/llvm/include/llvm/CodeGen/ValueTypes.h:48:13
 #8 0x00007faf96a150ba llvm::SelectionDAG::getNode(unsigned int, llvm::SDLoc const&, llvm::SDVTList, llvm::ArrayRef<llvm::SDValue>, llvm::SDNodeFlags) /scratch/nicolas.a.castaneda/llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:9407:3
 #9 0x00007faf96a1465a llvm::SelectionDAG::getNode(unsigned int, llvm::SDLoc const&, llvm::SDVTList, llvm::ArrayRef<llvm::SDValue>) /scratch/nicolas.a.castaneda/llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:9305:48
#10 0x00007faf9696f338 llvm::SelectionDAGBuilder::visitTargetIntrinsic(llvm::CallInst const&, unsigned int) /scratch/nicolas.a.castaneda/llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:4902:74
#11 0x00007faf96975870 llvm::SelectionDAGBuilder::visitIntrinsicCall(llvm::CallInst const&, unsigned int) /scratch/nicolas.a.castaneda/llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:5874:5
#12 0x00007faf96988602 llvm::SelectionDAGBuilder::visitCall(llvm::CallInst const&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:8384:9
#13 0x00007faf96955a9e llvm::SelectionDAGBuilder::visit(unsigned int, llvm::User const&) /scratch/nicolas.a.castaneda/llvm/llvm/include/llvm/IR/Instruction.def:209:1
#14 0x00007faf969552de llvm::SelectionDAGBuilder::visit(llvm::Instruction const&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:1170:22
#15 0x00007faf96a5c5a0 llvm::SelectionDAGISel::SelectBasicBlock(llvm::ilist_iterator<llvm::ilist_detail::node_options<llvm::Instruction, false, false, void>, false, true>, llvm::ilist_iterator<llvm::ilist_detail::node_options<llvm::Instruction, false, false, void>, false, true>, bool&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:687:79
#16 0x00007faf96a616e5 llvm::SelectionDAGISel::SelectAllBasicBlocks(llvm::Function const&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:1638:33
#17 0x00007faf96a5b177 llvm::SelectionDAGISel::runOnMachineFunction(llvm::MachineFunction&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:481:7
#18 0x00007fafa046ed62 llvm::RISCVDAGToDAGISel::runOnMachineFunction(llvm::MachineFunction&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.h:39:3
#19 0x00007faf9defb486 llvm::MachineFunctionPass::runOnFunction(llvm::Function&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/CodeGen/MachineFunctionPass.cpp:91:33
#20 0x00007faf98b3cfa0 llvm::FPPassManager::runOnFunction(llvm::Function&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/IR/LegacyPassManager.cpp:1430:20
#21 0x00007faf98b3d267 llvm::FPPassManager::runOnModule(llvm::Module&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/IR/LegacyPassManager.cpp:1476:13
#22 0x00007faf98b3d6d9 (anonymous namespace)::MPPassManager::runOnModule(llvm::Module&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/IR/LegacyPassManager.cpp:1545:20
#23 0x00007faf98b3866c llvm::legacy::PassManagerImpl::run(llvm::Module&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/IR/LegacyPassManager.cpp:535:13
#24 0x00007faf98b3dfa9 llvm::legacy::PassManager::run(llvm::Module&) /scratch/nicolas.a.castaneda/llvm/llvm/lib/IR/LegacyPassManager.cpp:1673:1
#25 0x00007faf9ee17bec (anonymous namespace)::EmitAssemblyHelper::RunCodegenPipeline(clang::BackendAction, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>&, std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>&) /scratch/nicolas.a.castaneda/llvm/clang/lib/CodeGen/BackendUtil.cpp:1084:51
#26 0x00007faf9ee17df0 (anonymous namespace)::EmitAssemblyHelper::EmitAssembly(clang::BackendAction, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>) /scratch/nicolas.a.castaneda/llvm/clang/lib/CodeGen/BackendUtil.cpp:1109:17
#27 0x00007faf9ee18eb3 clang::EmitBackendOutput(clang::DiagnosticsEngine&, clang::HeaderSearchOptions const&, clang::CodeGenOptions const&, clang::TargetOptions const&, clang::LangOptions const&, llvm::StringRef, llvm::Module*, clang::BackendAction, std::unique_ptr<llvm::raw_pwrite_stream, std::default_delete<llvm::raw_pwrite_stream>>) /scratch/nicolas.a.castaneda/llvm/clang/lib/CodeGen/BackendUtil.cpp:1268:25
#28 0x00007faf9f5fb178 clang::CodeGenAction::ExecuteAction() /scratch/nicolas.a.castaneda/llvm/clang/lib/CodeGen/CodeGenAction.cpp:1241:20
#29 0x00007faf9c717968 clang::FrontendAction::Execute() /scratch/nicolas.a.castaneda/llvm/clang/lib/Frontend/FrontendAction.cpp:1062:38
#30 0x00007faf9c62877d clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) /scratch/nicolas.a.castaneda/llvm/clang/lib/Frontend/CompilerInstance.cpp:1046:42
#31 0x00007fafa0318b63 clang::ExecuteCompilerInvocation(clang::CompilerInstance*) /scratch/nicolas.a.castaneda/llvm/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp:264:38
#32 0x000055f2b4c599a5 cc1_main(llvm::ArrayRef<char const*>, char const*, void*) /scratch/nicolas.a.castaneda/llvm/clang/tools/driver/cc1_main.cpp:251:40
#33 0x000055f2b4c46b41 ExecuteCC1Tool(llvm::SmallVectorImpl<char const*>&) /scratch/nicolas.a.castaneda/llvm/clang/tools/driver/driver.cpp:360:20
#34 0x00007faf9c104747 clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const::'lambda'()::operator()() const /scratch/nicolas.a.castaneda/llvm/clang/lib/Driver/Job.cpp:428:32
#35 0x00007faf9c104d4d void llvm::function_ref<void ()>::callback_fn<clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const::'lambda'()>(long) /scratch/nicolas.a.castaneda/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:46:40
#36 0x00007faf9792da72 llvm::function_ref<void ()>::operator()() const /scratch/nicolas.a.castaneda/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:62
#37 0x00007faf97942f64 llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) /scratch/nicolas.a.castaneda/llvm/llvm/lib/Support/CrashRecoveryContext.cpp:427:10
#38 0x00007faf9c104963 clang::driver::CC1Command::Execute(llvm::ArrayRef<std::optional<llvm::StringRef>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>*, bool*) const /scratch/nicolas.a.castaneda/llvm/clang/lib/Driver/Job.cpp:428:7
#39 0x00007faf9c087dfa clang::driver::Compilation::ExecuteCommand(clang::driver::Command const&, clang::driver::Command const*&, bool) const /scratch/nicolas.a.castaneda/llvm/clang/lib/Driver/Compilation.cpp:199:22
#40 0x00007faf9c088188 clang::driver::Compilation::ExecuteJobs(clang::driver::JobList const&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&, bool) const /scratch/nicolas.a.castaneda/llvm/clang/lib/Driver/Compilation.cpp:253:62
#41 0x00007faf9c0a1051 clang::driver::Driver::ExecuteCompilation(clang::driver::Compilation&, llvm::SmallVectorImpl<std::pair<int, clang::driver::Command const*>>&) /scratch/nicolas.a.castaneda/llvm/clang/lib/Driver/Driver.cpp:1856:28
#42 0x000055f2b4c4810e clang_main(int, char**) /scratch/nicolas.a.castaneda/llvm/clang/tools/driver/driver.cpp:562:39
#43 0x000055f2b4c7ccd6 main /scratch/nicolas.a.castaneda/llvm/build/tools/clang/tools/driver/clang-driver.cpp:11:63
#44 0x00007faf97468083 __libc_start_main /build/glibc-e2p3jK/glibc-2.31/csu/../csu/libc-start.c:342:3
#45 0x000055f2b4c4503e _start (/scratch/nicolas.a.castaneda/build/llvm-vortex/bin/clang+0x1103e)
clang-16: error: clang frontend command failed with exit code 139 (use -v to see invocation)
clang version 16.0.6 (https://github.com/vortexgpgpu/llvm 58811bfa61a503fd4a5f0dc7b57802fae51c3f5d)
Target: riscv32-unknown-unknown-elf
Thread model: posix
InstalledDir: /scratch/nicolas.a.castaneda/build/llvm-vortex/bin
clang-16: note: diagnostic msg: Error generating preprocessed source(s) - no preprocessable inputs.
[2024-05-06 22:53:34.294749659] POCL: in fn int pocl_llvm_build_vortex_program(cl_kernel, unsigned int, cl_device_id, const char*, const char*, char*) at line 114:
  *** ERROR ***  |     ERROR |  isVortex ? 1 
; ModuleID = '/home/eecs/nicolas.a.castaneda/.cache/pocl/kcache/PH/OJHLLAIOAHLNICJFIGMMKLAIJOPDBOGOODMAO/matmul/0-0-0/parallel.bc'
source_filename = "parallel_bc"
target datalayout = "e-m:e-p:32:32-i64:64-n32-S128"
target triple = "riscv32-unknown-unknown-elf"

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float) #0

; Function Attrs: alwaysinline norecurse nounwind
define void @_pocl_kernel_matmul(ptr nocapture noundef readonly align 4 %0, ptr nocapture noundef readonly align 4 %1, ptr nocapture noundef writeonly align 4 %2, i32 noundef %3, ptr nocapture noundef align 4 %4, ptr nocapture noundef align 4 %5, ptr nocapture readonly %6, i32 %7, i32 %8, i32 %9) local_unnamed_addr #1 !kernel_arg_addr_space !28 !kernel_arg_access_qual !29 !kernel_arg_type !30 !kernel_arg_base_type !30 !kernel_arg_type_qual !31 !kernel_arg_name !32 !pocl_generated !33 {
  %11 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2
  %12 = load i32, ptr %11, align 4
  %.fr = freeze i32 %12
  %13 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load i32, ptr %13, align 4
  %mul.i.i = mul i32 %.fr, %7
  %add.i.i = add i32 %mul.i.i, %14
  %cmp61.not.i = icmp eq i32 %3, 0
  %V.cmp61.not.i.i32 = zext i1 %cmp61.not.i to i32
  %15 = call i32 @llvm.riscv.vx.split.i32.i32(i32 %V.cmp61.not.i.i32)
  br i1 %cmp61.not.i, label %join_stub15, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i

for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i: ; preds = %10
  %16 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 1, i32 1
  %17 = load i32, ptr %16, align 4
  %18 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %6, i32 0, i32 2, i32 1
  %19 = load i32, ptr %18, align 4
  %nw = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 3, i32 %nw)
  %mul3.i.i = mul i32 %19, %8
  %add6.i.i = add i32 %mul3.i.i, %17
  %mul.i = mul i32 %add6.i.i, %3
  %cmp1758.i = icmp sgt i32 %.fr, 0
  %nw18 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 4, i32 %nw18)
  %V.cmp1758.i.i32 = zext i1 %cmp1758.i to i32
  %20 = call i32 @llvm.riscv.vx.split.i32.i32(i32 %V.cmp1758.i.i32)
  br i1 %cmp1758.i, label %for.body.prebarrier.i.us.preheader, label %for.body.prebarrier.i.preheader

for.body.prebarrier.i.preheader:                  ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
  %21 = shl i32 %add.i.i, 2
  %uglygep5 = getelementptr i8, ptr %1, i32 %21
  %22 = mul i32 %.fr, %3
  %23 = shl i32 %22, 2
  %24 = mul i32 %3, %add6.i.i
  %25 = shl i32 %24, 2
  %uglygep8 = getelementptr i8, ptr %0, i32 %25
  %26 = shl i32 %.fr, 2
  %tmask = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body.prebarrier.i

for.body.prebarrier.i.us.preheader:               ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i
  %27 = shl i32 %.fr, 2
  %tmask11 = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body.prebarrier.i.us

for.body.prebarrier.i.us:                         ; preds = %for.cond.cleanup18.loopexit.i.us, %for.body.prebarrier.i.us.preheader
  %.lcssa5.us = phi float [ 0.000000e+00, %for.body.prebarrier.i.us.preheader ], [ %34, %for.cond.cleanup18.loopexit.i.us ]
  %28 = phi i32 [ 0, %for.body.prebarrier.i.us.preheader ], [ %35, %for.cond.cleanup18.loopexit.i.us ]
  %add5.i.us = add i32 %28, %mul.i
  %arrayidx.i.us = getelementptr inbounds float, ptr %0, i32 %add5.i.us
  %29 = load float, ptr %arrayidx.i.us, align 4, !tbaa !34
  store float %29, ptr %4, align 4, !tbaa !34
  %mul10.i.us = mul i32 %28, %3
  %add11.i.us = add i32 %mul10.i.us, %add.i.i
  %arrayidx12.i.us = getelementptr inbounds float, ptr %1, i32 %add11.i.us
  %30 = load float, ptr %arrayidx12.i.us, align 4, !tbaa !34
  store float %30, ptr %5, align 4, !tbaa !34
  %nw19 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 1, i32 %nw19)
  %nw20 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 2, i32 %nw20)
  %nw21 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 8, i32 %nw21)
  %tmask12 = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us

for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us: ; preds = %for.body.prebarrier.i.us, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %4, %for.body.prebarrier.i.us ]
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %5, %for.body.prebarrier.i.us ]
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.fr, %for.body.prebarrier.i.us ]
  %31 = phi float [ %34, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.us ]
  %nw22 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 9, i32 %nw22)
  %32 = load float, ptr %lsr.iv3, align 4, !tbaa !34
  %33 = load float, ptr %lsr.iv2, align 4, !tbaa !34
  %34 = tail call float @llvm.fmuladd.f32(float %32, float %33, float %31)
  %nw23 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 10, i32 %nw23)
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %27
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
  %exitcond.not.i.us = icmp eq i32 %lsr.iv.next, 0
  %V.exitcond.not.i.us.not = xor i1 %exitcond.not.i.us, true
  %V.V.exitcond.not.i.us.not.i32 = zext i1 %V.exitcond.not.i.us.not to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.V.exitcond.not.i.us.not.i32, i32 %tmask12)
  br i1 %exitcond.not.i.us, label %for.cond.cleanup18.loopexit.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us, !llvm.loop !38

for.cond.cleanup18.loopexit.i.us:                 ; preds = %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.us
  %nw24 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 11, i32 %nw24)
  %35 = add nsw i32 %28, %.fr
  %nw25 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 12, i32 %nw25)
  %36 = icmp uge i32 %35, %3
  %V.43.not = xor i1 %36, true
  %V.V.43.not.i32 = zext i1 %V.43.not to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.V.43.not.i32, i32 %tmask11)
  br i1 %36, label %for.cond.cleanup.loopexit.btr.i, label %for.body.prebarrier.i.us

for.cond.cleanup.loopexit.i:                      ; preds = %for.body.prebarrier.i
  %37 = add i32 %mul.i, %add.i.i
  br label %join_stub

for.body.prebarrier.i:                            ; preds = %for.body.prebarrier.i.preheader, %for.body.prebarrier.i
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.preheader ], [ %uglygep10, %for.body.prebarrier.i ]
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.preheader ], [ %uglygep7, %for.body.prebarrier.i ]
  %38 = phi i32 [ %add28.i, %for.body.prebarrier.i ], [ 0, %for.body.prebarrier.i.preheader ]
  %39 = load float, ptr %lsr.iv9, align 4, !tbaa !34
  store float %39, ptr %4, align 4, !tbaa !34
  %40 = load float, ptr %lsr.iv6, align 4, !tbaa !34
  store float %40, ptr %5, align 4, !tbaa !34
  %nw26 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 13, i32 %nw26)
  %nw27 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 14, i32 %nw27)
  %add28.i = add i32 %38, %.fr
  %nw28 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 15, i32 %nw28)
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %23
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %26
  %cmp.i = icmp ult i32 %add28.i, %3
  %V.cmp.i.i32 = zext i1 %cmp.i to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.cmp.i.i32, i32 %tmask)
  br i1 %cmp.i, label %for.body.prebarrier.i, label %for.cond.cleanup.loopexit.i, !llvm.loop !40

for.cond.cleanup.loopexit.btr.i:                  ; preds = %for.cond.cleanup18.loopexit.i.us
  %41 = add i32 %mul.i, %add.i.i
  br label %join_stub

join_stub:                                        ; preds = %for.cond.cleanup.loopexit.btr.i, %for.cond.cleanup.loopexit.i
  %.lcssa.lcssa.sink14 = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i ], [ %34, %for.cond.cleanup.loopexit.btr.i ]
  %.sink913 = phi i32 [ %37, %for.cond.cleanup.loopexit.i ], [ %41, %for.cond.cleanup.loopexit.btr.i ]
  call void @llvm.riscv.vx.join.i32(i32 %20)
  br label %join_stub15

join_stub15:                                      ; preds = %10, %join_stub
  %.lcssa.lcssa.sink17 = phi float [ %.lcssa.lcssa.sink14, %join_stub ], [ 0.000000e+00, %10 ]
  %.sink916 = phi i32 [ %.sink913, %join_stub ], [ %add.i.i, %10 ]
  call void @llvm.riscv.vx.join.i32(i32 %15)
  br label %matmul.exit

matmul.exit:                                      ; preds = %join_stub15
  %.sink9 = phi i32 [ %.sink916, %join_stub15 ]
  %.lcssa.lcssa.sink = phi float [ %.lcssa.lcssa.sink17, %join_stub15 ]
  %42 = getelementptr inbounds float, ptr %2, i32 %.sink9
  store float %.lcssa.lcssa.sink, ptr %42, align 4, !tbaa !34
  ret void
}

; Function Attrs: nounwind
define void @_pocl_kernel_matmul_workgroup(ptr nocapture readonly %0, ptr nocapture readonly %1, i32 %2, i32 %3, i32 %4) local_unnamed_addr #2 {
  %6 = getelementptr ptr, ptr %0, i32 2
  %7 = load ptr, ptr %6, align 4
  %8 = load ptr, ptr %7, align 4
  %9 = getelementptr ptr, ptr %0, i32 3
  %10 = load ptr, ptr %9, align 4
  %11 = load i32, ptr %10, align 4
  %12 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2
  %13 = load i32, ptr %12, align 4
  %.fr = freeze i32 %13
  %14 = getelementptr inbounds { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1
  %15 = load i32, ptr %14, align 4
  %mul.i.i.i = mul i32 %.fr, %2
  %add.i.i.i = add i32 %mul.i.i.i, %15
  %cmp61.not.i.i = icmp eq i32 %11, 0
  %V.cmp61.not.i.i.i32 = zext i1 %cmp61.not.i.i to i32
  %16 = call i32 @llvm.riscv.vx.split.i32.i32(i32 %V.cmp61.not.i.i.i32)
  br i1 %cmp61.not.i.i, label %join_stub15, label %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i

for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i: ; preds = %5
  %17 = load ptr, ptr %0, align 4
  %18 = load ptr, ptr %17, align 4
  %19 = getelementptr ptr, ptr %0, i32 1
  %20 = load ptr, ptr %19, align 4
  %21 = load ptr, ptr %20, align 4
  %22 = getelementptr ptr, ptr %0, i32 4
  %23 = load ptr, ptr %22, align 4
  %24 = load ptr, ptr %23, align 4
  %25 = getelementptr ptr, ptr %0, i32 5
  %26 = load ptr, ptr %25, align 4
  %27 = load ptr, ptr %26, align 4
  %28 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 1, i32 1
  %29 = load i32, ptr %28, align 4
  %30 = getelementptr { [3 x i32], [3 x i32], [3 x i32], ptr, ptr, i32, ptr, i32 }, ptr %1, i32 0, i32 2, i32 1
  %31 = load i32, ptr %30, align 4
  %nw = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 16, i32 %nw)
  %mul3.i.i.i = mul i32 %31, %3
  %add6.i.i.i = add i32 %mul3.i.i.i, %29
  %mul.i.i = mul i32 %add6.i.i.i, %11
  %cmp1758.i.i = icmp sgt i32 %.fr, 0
  %nw18 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 17, i32 %nw18)
  %V.cmp1758.i.i.i32 = zext i1 %cmp1758.i.i to i32
  %32 = call i32 @llvm.riscv.vx.split.i32.i32(i32 %V.cmp1758.i.i.i32)
  br i1 %cmp1758.i.i, label %for.body.prebarrier.i.i.us.preheader, label %for.body.prebarrier.i.i.preheader

for.body.prebarrier.i.i.preheader:                ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
  %33 = shl i32 %add.i.i.i, 2
  %uglygep5 = getelementptr i8, ptr %21, i32 %33
  %34 = mul i32 %.fr, %11
  %35 = shl i32 %34, 2
  %36 = mul i32 %11, %add6.i.i.i
  %37 = shl i32 %36, 2
  %uglygep8 = getelementptr i8, ptr %18, i32 %37
  %38 = shl i32 %.fr, 2
  %tmask = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body.prebarrier.i.i

for.body.prebarrier.i.i.us.preheader:             ; preds = %for.body.lr.ph.loopbarrier.prebarrier.prebarrier.i.i
  %39 = shl i32 %.fr, 2
  %tmask11 = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body.prebarrier.i.i.us

for.body.prebarrier.i.i.us:                       ; preds = %for.cond.cleanup18.loopexit.i.i.us, %for.body.prebarrier.i.i.us.preheader
  %.lcssa5.us = phi float [ 0.000000e+00, %for.body.prebarrier.i.i.us.preheader ], [ %46, %for.cond.cleanup18.loopexit.i.i.us ]
  %40 = phi i32 [ 0, %for.body.prebarrier.i.i.us.preheader ], [ %47, %for.cond.cleanup18.loopexit.i.i.us ]
  %add5.i.i.us = add i32 %40, %mul.i.i
  %arrayidx.i.i.us = getelementptr inbounds float, ptr %18, i32 %add5.i.i.us
  %41 = load float, ptr %arrayidx.i.i.us, align 4, !tbaa !34
  store float %41, ptr %24, align 4, !tbaa !34
  %mul10.i.i.us = mul i32 %40, %11
  %add11.i.i.us = add i32 %mul10.i.i.us, %add.i.i.i
  %arrayidx12.i.i.us = getelementptr inbounds float, ptr %21, i32 %add11.i.i.us
  %42 = load float, ptr %arrayidx12.i.i.us, align 4, !tbaa !34
  store float %42, ptr %27, align 4, !tbaa !34
  %nw19 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 18, i32 %nw19)
  %nw20 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 19, i32 %nw20)
  %nw21 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 20, i32 %nw21)
  %tmask12 = call i32 @llvm.riscv.vx.tmask.i32()
  br label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us

for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us: ; preds = %for.body.prebarrier.i.i.us, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us
  %lsr.iv3 = phi ptr [ %uglygep4, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %24, %for.body.prebarrier.i.i.us ]
  %lsr.iv2 = phi ptr [ %uglygep, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %27, %for.body.prebarrier.i.i.us ]
  %lsr.iv = phi i32 [ %lsr.iv.next, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.fr, %for.body.prebarrier.i.i.us ]
  %43 = phi float [ %46, %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us ], [ %.lcssa5.us, %for.body.prebarrier.i.i.us ]
  %nw22 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 21, i32 %nw22)
  %44 = load float, ptr %lsr.iv3, align 4, !tbaa !34
  %45 = load float, ptr %lsr.iv2, align 4, !tbaa !34
  %46 = tail call float @llvm.fmuladd.f32(float %44, float %45, float %43)
  %nw23 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 22, i32 %nw23)
  %lsr.iv.next = add i32 %lsr.iv, -1
  %uglygep = getelementptr i8, ptr %lsr.iv2, i32 %39
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4
  %exitcond.not.i.i.us = icmp eq i32 %lsr.iv.next, 0
  %V.exitcond.not.i.i.us.not = xor i1 %exitcond.not.i.i.us, true
  %V.V.exitcond.not.i.i.us.not.i32 = zext i1 %V.exitcond.not.i.i.us.not to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.V.exitcond.not.i.i.us.not.i32, i32 %tmask12)
  br i1 %exitcond.not.i.i.us, label %for.cond.cleanup18.loopexit.i.i.us, label %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us, !llvm.loop !38

for.cond.cleanup18.loopexit.i.i.us:               ; preds = %for.body19.brexitbarrier.latchbarrier.prebarrier.prebarrier.i.i.us
  %nw24 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 23, i32 %nw24)
  %47 = add nsw i32 %40, %.fr
  %nw25 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 24, i32 %nw25)
  %48 = icmp uge i32 %47, %11
  %V.55.not = xor i1 %48, true
  %V.V.55.not.i32 = zext i1 %V.55.not to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.V.55.not.i32, i32 %tmask11)
  br i1 %48, label %for.cond.cleanup.loopexit.btr.i.i, label %for.body.prebarrier.i.i.us

for.cond.cleanup.loopexit.i.i:                    ; preds = %for.body.prebarrier.i.i
  %49 = add i32 %mul.i.i, %add.i.i.i
  br label %join_stub

for.body.prebarrier.i.i:                          ; preds = %for.body.prebarrier.i.i.preheader, %for.body.prebarrier.i.i
  %lsr.iv9 = phi ptr [ %uglygep8, %for.body.prebarrier.i.i.preheader ], [ %uglygep10, %for.body.prebarrier.i.i ]
  %lsr.iv6 = phi ptr [ %uglygep5, %for.body.prebarrier.i.i.preheader ], [ %uglygep7, %for.body.prebarrier.i.i ]
  %50 = phi i32 [ %add28.i.i, %for.body.prebarrier.i.i ], [ 0, %for.body.prebarrier.i.i.preheader ]
  %51 = load float, ptr %lsr.iv9, align 4, !tbaa !34
  store float %51, ptr %24, align 4, !tbaa !34
  %52 = load float, ptr %lsr.iv6, align 4, !tbaa !34
  store float %52, ptr %27, align 4, !tbaa !34
  %nw26 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 5, i32 %nw26)
  %nw27 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 6, i32 %nw27)
  %add28.i.i = add i32 %50, %.fr
  %nw28 = call i32 @llvm.riscv.vx.nw.i32()
  call void @llvm.riscv.vx.bar.i32.i32(i32 7, i32 %nw28)
  %uglygep7 = getelementptr i8, ptr %lsr.iv6, i32 %35
  %uglygep10 = getelementptr i8, ptr %lsr.iv9, i32 %38
  %cmp.i.i = icmp ult i32 %add28.i.i, %11
  %V.cmp.i.i.i32 = zext i1 %cmp.i.i to i32
  call void @llvm.riscv.vx.pred.i32.i32(i32 %V.cmp.i.i.i32, i32 %tmask)
  br i1 %cmp.i.i, label %for.body.prebarrier.i.i, label %for.cond.cleanup.loopexit.i.i, !llvm.loop !40

for.cond.cleanup.loopexit.btr.i.i:                ; preds = %for.cond.cleanup18.loopexit.i.i.us
  %53 = add i32 %mul.i.i, %add.i.i.i
  br label %join_stub

join_stub:                                        ; preds = %for.cond.cleanup.loopexit.btr.i.i, %for.cond.cleanup.loopexit.i.i
  %.sink14 = phi float [ 0.000000e+00, %for.cond.cleanup.loopexit.i.i ], [ %46, %for.cond.cleanup.loopexit.btr.i.i ]
  %.sink1013 = phi i32 [ %49, %for.cond.cleanup.loopexit.i.i ], [ %53, %for.cond.cleanup.loopexit.btr.i.i ]
  call void @llvm.riscv.vx.join.i32(i32 %32)
  br label %join_stub15

join_stub15:                                      ; preds = %5, %join_stub
  %.sink17 = phi float [ %.sink14, %join_stub ], [ 0.000000e+00, %5 ]
  %.sink1016 = phi i32 [ %.sink1013, %join_stub ], [ %add.i.i.i, %5 ]
  call void @llvm.riscv.vx.join.i32(i32 %16)
  br label %_pocl_kernel_matmul.exit

_pocl_kernel_matmul.exit:                         ; preds = %join_stub15
  %.sink10 = phi i32 [ %.sink1016, %join_stub15 ]
  %.sink = phi float [ %.sink17, %join_stub15 ]
  %54 = getelementptr inbounds float, ptr %8, i32 %.sink10
  store float %.sink, ptr %54, align 4, !tbaa !34
  ret void
}

; Function Attrs: nounwind
declare i32 @llvm.riscv.vx.tmask.i32() #2

; Function Attrs: convergent nounwind
declare void @llvm.riscv.vx.pred.i32.i32(i32, i32) #3

; Function Attrs: convergent nounwind
declare void @llvm.riscv.vx.tmc.i32(i32) #3

; Function Attrs: convergent nounwind
declare i32 @llvm.riscv.vx.split.i32.i32(i32) #3

; Function Attrs: convergent nounwind
declare void @llvm.riscv.vx.join.i32(i32) #3

; Function Attrs: nounwind memory(none)
declare void @llvm.riscv.vx.bar.i32.i32(i32, i32) #4

; Function Attrs: nounwind willreturn memory(none)
declare i32 @llvm.riscv.vx.tid.i32() #5

; Function Attrs: nounwind willreturn memory(none)
declare i32 @llvm.riscv.vx.wid.i32() #5

; Function Attrs: nounwind willreturn memory(none)
declare i32 @llvm.riscv.vx.cid.i32() #5

; Function Attrs: nounwind willreturn memory(none)
declare i32 @llvm.riscv.vx.gid.i32() #5

; Function Attrs: nounwind willreturn memory(none)
declare i32 @llvm.riscv.vx.nt.i32() #5

; Function Attrs: nounwind willreturn memory(none)
declare i32 @llvm.riscv.vx.nw.i32() #5

; Function Attrs: nounwind willreturn memory(none)
declare i32 @llvm.riscv.vx.nc.i32() #5

; Function Attrs: nounwind willreturn memory(none)
declare i32 @llvm.riscv.vx.ng.i32() #5

attributes #0 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #1 = { alwaysinline norecurse nounwind "no-builtins" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "stackrealign" "target-features"="+32bit,+f,+m,+vortex" "uniform-work-group-size"="false" }
attributes #2 = { nounwind }
attributes #3 = { convergent nounwind }
attributes #4 = { nounwind memory(none) }
attributes #5 = { nounwind willreturn memory(none) }

!llvm.module.flags = !{!0, !1, !2, !3}
!opencl.ocl.version = !{!4}
!llvm.ident = !{!5}
!pocl_meta = !{!6, !7, !8, !9, !10, !11, !12, !13, !14, !15, !16, !17, !18, !19, !20, !21, !22, !23, !24, !25, !26, !27}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32f"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 1, !"SmallDataLimit", i32 0}
!4 = !{i32 3, i32 0}
!5 = !{!"clang version 16.0.6 (https://github.com/vortexgpgpu/llvm 58811bfa61a503fd4a5f0dc7b57802fae51c3f5d)"}
!6 = !{!"device_address_bits", i64 32}
!7 = !{!"device_arg_buffer_launcher", i8 0}
!8 = !{!"device_grid_launcher", i8 0}
!9 = !{!"device_is_spmd", i8 0}
!10 = !{!"KernelName", !"matmul"}
!11 = !{!"WGMaxGridDimWidth", i64 0}
!12 = !{!"WGLocalSizeX", i64 0}
!13 = !{!"WGLocalSizeY", i64 0}
!14 = !{!"WGLocalSizeZ", i64 0}
!15 = !{!"WGDynamicLocalSize", i8 1}
!16 = !{!"WGAssumeZeroGlobalOffset", i8 0}
!17 = !{!"device_global_as_id", i64 0}
!18 = !{!"device_local_as_id", i64 0}
!19 = !{!"device_constant_as_id", i64 0}
!20 = !{!"device_args_as_id", i64 0}
!21 = !{!"device_context_as_id", i64 0}
!22 = !{!"device_side_printf", i8 1}
!23 = !{!"device_alloca_locals", i8 0}
!24 = !{!"device_max_witem_dim", i64 3}
!25 = !{!"device_max_witem_sizes_0", i64 4096}
!26 = !{!"device_max_witem_sizes_1", i64 4096}
!27 = !{!"device_max_witem_sizes_2", i64 4096}
!28 = !{i32 1, i32 1, i32 1, i32 0, i32 3, i32 3}
!29 = !{!"none", !"none", !"none", !"none", !"none", !"none"}
!30 = !{!"float*", !"float*", !"float*", !"uint", !"float*", !"float*"}
!31 = !{!"", !"", !"", !"", !"", !""}
!32 = !{!"A", !"B", !"C", !"N", !"localA", !"localB"}
!33 = !{i32 1}
!34 = !{!35, !35, i64 0}
!35 = !{!"float", !36, i64 0}
!36 = !{!"omnipotent char", !37, i64 0}
!37 = !{!"Simple C/C++ TBAA"}
!38 = distinct !{!38, !39}
!39 = !{!"llvm.loop.unroll.disable"}
!40 = distinct !{!40, !39}


[2024-05-06 22:53:34.294789959] POCL: in fn llvm_codegen at line 543:
  *** INFO ***  |      LLVM |  Vortex compilation kernel.o -> kernel.hex has failed
[2024-05-06 22:53:34.295128234] POCL: in fn llvm_codegen at line 616:
  *** INFO ***  |    TIMING |       >>>         6.809932412  s    API: llvm_codegen
Final linking of kernel matmul failed.
make: *** [../common.mk:76: kernel.pocl] Aborted (core dumped)
